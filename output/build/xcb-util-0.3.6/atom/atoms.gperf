%{

/* Rely on vasprintf (GNU extension) instead of vsnprintf if
   possible... */
#ifdef HAVE_VASPRINTF
#define _GNU_SOURCE
#include <stdio.h>
#endif

#include <xcb/xcb.h>
#include <stdlib.h>
#include <stdarg.h>
#include "xcb_atom.h"

const xcb_atom_t PRIMARY = 1;
const xcb_atom_t SECONDARY = 2;
const xcb_atom_t ARC = 3;
const xcb_atom_t ATOM = 4;
const xcb_atom_t BITMAP = 5;
const xcb_atom_t CARDINAL = 6;
const xcb_atom_t COLORMAP = 7;
const xcb_atom_t CURSOR = 8;
const xcb_atom_t CUT_BUFFER0 = 9;
const xcb_atom_t CUT_BUFFER1 = 10;
const xcb_atom_t CUT_BUFFER2 = 11;
const xcb_atom_t CUT_BUFFER3 = 12;
const xcb_atom_t CUT_BUFFER4 = 13;
const xcb_atom_t CUT_BUFFER5 = 14;
const xcb_atom_t CUT_BUFFER6 = 15;
const xcb_atom_t CUT_BUFFER7 = 16;
const xcb_atom_t DRAWABLE = 17;
const xcb_atom_t FONT = 18;
const xcb_atom_t INTEGER = 19;
const xcb_atom_t PIXMAP = 20;
const xcb_atom_t POINT = 21;
const xcb_atom_t RECTANGLE = 22;
const xcb_atom_t RESOURCE_MANAGER = 23;
const xcb_atom_t RGB_COLOR_MAP = 24;
const xcb_atom_t RGB_BEST_MAP = 25;
const xcb_atom_t RGB_BLUE_MAP = 26;
const xcb_atom_t RGB_DEFAULT_MAP = 27;
const xcb_atom_t RGB_GRAY_MAP = 28;
const xcb_atom_t RGB_GREEN_MAP = 29;
const xcb_atom_t RGB_RED_MAP = 30;
const xcb_atom_t STRING = 31;
const xcb_atom_t VISUALID = 32;
const xcb_atom_t WINDOW = 33;
const xcb_atom_t WM_COMMAND = 34;
const xcb_atom_t WM_HINTS = 35;
const xcb_atom_t WM_CLIENT_MACHINE = 36;
const xcb_atom_t WM_ICON_NAME = 37;
const xcb_atom_t WM_ICON_SIZE = 38;
const xcb_atom_t WM_NAME = 39;
const xcb_atom_t WM_NORMAL_HINTS = 40;
const xcb_atom_t WM_SIZE_HINTS = 41;
const xcb_atom_t WM_ZOOM_HINTS = 42;
const xcb_atom_t MIN_SPACE = 43;
const xcb_atom_t NORM_SPACE = 44;
const xcb_atom_t MAX_SPACE = 45;
const xcb_atom_t END_SPACE = 46;
const xcb_atom_t SUPERSCRIPT_X = 47;
const xcb_atom_t SUPERSCRIPT_Y = 48;
const xcb_atom_t SUBSCRIPT_X = 49;
const xcb_atom_t SUBSCRIPT_Y = 50;
const xcb_atom_t UNDERLINE_POSITION = 51;
const xcb_atom_t UNDERLINE_THICKNESS = 52;
const xcb_atom_t STRIKEOUT_ASCENT = 53;
const xcb_atom_t STRIKEOUT_DESCENT = 54;
const xcb_atom_t ITALIC_ANGLE = 55;
const xcb_atom_t X_HEIGHT = 56;
const xcb_atom_t QUAD_WIDTH = 57;
const xcb_atom_t WEIGHT = 58;
const xcb_atom_t POINT_SIZE = 59;
const xcb_atom_t RESOLUTION = 60;
const xcb_atom_t COPYRIGHT = 61;
const xcb_atom_t NOTICE = 62;
const xcb_atom_t FONT_NAME = 63;
const xcb_atom_t FAMILY_NAME = 64;
const xcb_atom_t FULL_NAME = 65;
const xcb_atom_t CAP_HEIGHT = 66;
const xcb_atom_t WM_CLASS = 67;
const xcb_atom_t WM_TRANSIENT_FOR = 68;
%}

%readonly-tables
%pic
%null-strings
%enum
%includes
%compare-strncmp

%struct-type
struct atom_map { int name; xcb_atom_t value; };
%%
PRIMARY,1
SECONDARY,2
ARC,3
ATOM,4
BITMAP,5
CARDINAL,6
COLORMAP,7
CURSOR,8
CUT_BUFFER0,9
CUT_BUFFER1,10
CUT_BUFFER2,11
CUT_BUFFER3,12
CUT_BUFFER4,13
CUT_BUFFER5,14
CUT_BUFFER6,15
CUT_BUFFER7,16
DRAWABLE,17
FONT,18
INTEGER,19
PIXMAP,20
POINT,21
RECTANGLE,22
RESOURCE_MANAGER,23
RGB_COLOR_MAP,24
RGB_BEST_MAP,25
RGB_BLUE_MAP,26
RGB_DEFAULT_MAP,27
RGB_GRAY_MAP,28
RGB_GREEN_MAP,29
RGB_RED_MAP,30
STRING,31
VISUALID,32
WINDOW,33
WM_COMMAND,34
WM_HINTS,35
WM_CLIENT_MACHINE,36
WM_ICON_NAME,37
WM_ICON_SIZE,38
WM_NAME,39
WM_NORMAL_HINTS,40
WM_SIZE_HINTS,41
WM_ZOOM_HINTS,42
MIN_SPACE,43
NORM_SPACE,44
MAX_SPACE,45
END_SPACE,46
SUPERSCRIPT_X,47
SUPERSCRIPT_Y,48
SUBSCRIPT_X,49
SUBSCRIPT_Y,50
UNDERLINE_POSITION,51
UNDERLINE_THICKNESS,52
STRIKEOUT_ASCENT,53
STRIKEOUT_DESCENT,54
ITALIC_ANGLE,55
X_HEIGHT,56
QUAD_WIDTH,57
WEIGHT,58
POINT_SIZE,59
RESOLUTION,60
COPYRIGHT,61
NOTICE,62
FONT_NAME,63
FAMILY_NAME,64
FULL_NAME,65
CAP_HEIGHT,66
WM_CLASS,67
WM_TRANSIENT_FOR,68
%%

static const char atom_names[] =
	"PRIMARY\0"
	"SECONDARY\0"
	"ARC\0"
	"ATOM\0"
	"BITMAP\0"
	"CARDINAL\0"
	"COLORMAP\0"
	"CURSOR\0"
	"CUT_BUFFER0\0"
	"CUT_BUFFER1\0"
	"CUT_BUFFER2\0"
	"CUT_BUFFER3\0"
	"CUT_BUFFER4\0"
	"CUT_BUFFER5\0"
	"CUT_BUFFER6\0"
	"CUT_BUFFER7\0"
	"DRAWABLE\0"
	"FONT\0"
	"INTEGER\0"
	"PIXMAP\0"
	"POINT\0"
	"RECTANGLE\0"
	"RESOURCE_MANAGER\0"
	"RGB_COLOR_MAP\0"
	"RGB_BEST_MAP\0"
	"RGB_BLUE_MAP\0"
	"RGB_DEFAULT_MAP\0"
	"RGB_GRAY_MAP\0"
	"RGB_GREEN_MAP\0"
	"RGB_RED_MAP\0"
	"STRING\0"
	"VISUALID\0"
	"WINDOW\0"
	"WM_COMMAND\0"
	"WM_HINTS\0"
	"WM_CLIENT_MACHINE\0"
	"WM_ICON_NAME\0"
	"WM_ICON_SIZE\0"
	"WM_NAME\0"
	"WM_NORMAL_HINTS\0"
	"WM_SIZE_HINTS\0"
	"WM_ZOOM_HINTS\0"
	"MIN_SPACE\0"
	"NORM_SPACE\0"
	"MAX_SPACE\0"
	"END_SPACE\0"
	"SUPERSCRIPT_X\0"
	"SUPERSCRIPT_Y\0"
	"SUBSCRIPT_X\0"
	"SUBSCRIPT_Y\0"
	"UNDERLINE_POSITION\0"
	"UNDERLINE_THICKNESS\0"
	"STRIKEOUT_ASCENT\0"
	"STRIKEOUT_DESCENT\0"
	"ITALIC_ANGLE\0"
	"X_HEIGHT\0"
	"QUAD_WIDTH\0"
	"WEIGHT\0"
	"POINT_SIZE\0"
	"RESOLUTION\0"
	"COPYRIGHT\0"
	"NOTICE\0"
	"FONT_NAME\0"
	"FAMILY_NAME\0"
	"FULL_NAME\0"
	"CAP_HEIGHT\0"
	"WM_CLASS\0"
	"WM_TRANSIENT_FOR\0"
;

static const uint16_t atom_name_offsets[] = {
	0,
	8,
	18,
	22,
	27,
	34,
	43,
	52,
	59,
	71,
	83,
	95,
	107,
	119,
	131,
	143,
	155,
	164,
	169,
	177,
	184,
	190,
	200,
	217,
	231,
	244,
	257,
	273,
	286,
	300,
	312,
	319,
	328,
	335,
	346,
	355,
	373,
	386,
	399,
	407,
	423,
	437,
	451,
	461,
	472,
	482,
	492,
	506,
	520,
	532,
	544,
	563,
	583,
	600,
	618,
	631,
	640,
	651,
	658,
	669,
	680,
	690,
	697,
	707,
	719,
	729,
	740,
	749,
};

xcb_atom_t xcb_atom_get(xcb_connection_t *connection, const char *atom_name)
{
	if(atom_name == NULL)
		return XCB_NONE;
	xcb_intern_atom_reply_t *reply = xcb_intern_atom_reply(connection,
		xcb_intern_atom(connection, 0, strlen(atom_name), atom_name), NULL);
	if(!reply)
		return XCB_NONE;
	xcb_atom_t atom = reply->atom;
	free(reply);
	return atom;
}

xcb_atom_t xcb_atom_get_predefined(uint16_t name_len, const char *name)
{
	const struct atom_map *value = in_word_set(name, name_len);
	xcb_atom_t ret = XCB_NONE;
	if(value)
		ret = value->value;
	return ret;
}

xcb_atom_fast_cookie_t xcb_atom_get_fast(xcb_connection_t *c, uint8_t only_if_exists, uint16_t name_len, const char *name)
{
	xcb_atom_fast_cookie_t cookie;

	if((cookie.u.atom = xcb_atom_get_predefined(name_len, name)) != XCB_NONE)
	{
		cookie.tag = TAG_VALUE;
		return cookie;
	}

	cookie.tag = TAG_COOKIE;
	cookie.u.cookie = xcb_intern_atom(c, only_if_exists, name_len, name);
	return cookie;
}

xcb_atom_t xcb_atom_get_fast_reply(xcb_connection_t *c, xcb_atom_fast_cookie_t cookie, xcb_generic_error_t **e)
{
	switch(cookie.tag)
	{
		xcb_intern_atom_reply_t *reply;
	case TAG_VALUE:
		if(e)
			*e = 0;
		break;
	case TAG_COOKIE:
		reply = xcb_intern_atom_reply(c, cookie.u.cookie, e);
		if(reply)
		{
			cookie.u.atom = reply->atom;
			free(reply);
		}
		else
			cookie.u.atom = XCB_NONE;
		break;
	}
	return cookie.u.atom;
}

const char *xcb_atom_get_name_predefined(xcb_atom_t atom)
{
	if(atom <= 0 || atom > (sizeof(atom_name_offsets) / sizeof(*atom_name_offsets)))
		return 0;
	return atom_names + atom_name_offsets[atom - 1];
}

int xcb_atom_get_name(xcb_connection_t *c, xcb_atom_t atom, const char **namep, int *lengthp)
{
	static char buf[100];
	const char *name = xcb_atom_get_name_predefined(atom);
	int namelen;
	xcb_get_atom_name_cookie_t atomc;
	xcb_get_atom_name_reply_t *atomr;
	if(name)
	{
		*namep = name;
		*lengthp = strlen(name);
		return 1;
	}
	atomc = xcb_get_atom_name(c, atom);
	atomr = xcb_get_atom_name_reply(c, atomc, 0);
	if(!atomr)
		return 0;
	namelen = xcb_get_atom_name_name_length(atomr);
	if(namelen > sizeof(buf))
		namelen = sizeof(buf);
	*lengthp = namelen;
	memcpy(buf, xcb_get_atom_name_name(atomr), namelen);
	*namep = buf;
	free(atomr);
	return 1;
}

static char *makename(const char *fmt, ...)
{
	char *ret;
	int n;
	va_list ap;

#ifndef HAVE_VASPRINTF
	char *np;
	int size = 64;

	/* First allocate 'size' bytes, should be enough usually */
	if((ret = malloc(size)) == NULL)
		return NULL;

	while(1)
	{
		va_start(ap, fmt);
		n = vsnprintf(ret, size, fmt, ap);
		va_end(ap);

		if(n < 0)
			return NULL;

		if(n < size)
			return ret;

		size = n + 1;
		if((np = realloc(ret, size)) == NULL)
		{
			free(ret);
			return NULL;
		}

		ret = np;
	}
#else
	va_start(ap, fmt);
	n = vasprintf(&ret, fmt, ap);
	va_end(ap);

	if(n < 0)
		return NULL;

	return ret;
#endif
}

char *xcb_atom_name_by_screen(const char *base, uint8_t screen)
{
	return makename("%s_S%u", base, screen);
}

char *xcb_atom_name_by_resource(const char *base, uint32_t resource)
{
	return makename("%s_R%08X", base, resource);
}

char *xcb_atom_name_unique(const char *base, uint32_t id)
{
	if(base)
		return makename("%s_U%lu", base, id);
	else
		return makename("U%lu", id);
}
