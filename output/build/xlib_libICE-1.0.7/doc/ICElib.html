<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Inter-Client Exchange Library</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div class="book" title="Inter-Client Exchange Library"><div class="titlepage"><div><div><h1 class="title"><a id="icelib"></a>Inter-Client Exchange Library</h1></div><div><h2 class="subtitle">X Consortium Standard</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Ralph</span> <span class="surname">Mor</span></h3><div class="affiliation"><span class="orgname">X Consortium<br /></span></div></div></div></div><div><p class="releaseinfo">X Version 11, Release 6.4</p></div><div><p class="copyright">Copyright © 1993 X Consortium</p></div><div><p class="copyright">Copyright © 1994 X Consortium</p></div><div><p class="copyright">Copyright © 1996 X Consortium</p></div><div><div class="legalnotice" title="Legal Notice"><a id="idp626776"></a><p>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the
"Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and
to permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p><p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p><p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p><p>
Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.
</p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 1.0</td><td align="left"></td></tr></table></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#overview_of_ice">1. Overview of ICE</a></span></dt><dt><span class="chapter"><a href="#the_ice_library__c_language_interface_to">2. The ICE Library - C Language Interface to ICE</a></span></dt><dt><span class="chapter"><a href="#intended_audience">3. Intended Audience</a></span></dt><dt><span class="chapter"><a href="#header_files_and_library_name">4. Header Files and Library Name</a></span></dt><dt><span class="chapter"><a href="#note_on_prefixes">5. Note on Prefixes</a></span></dt><dt><span class="chapter"><a href="#protocol_registration">6. Protocol Registration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#callbacks_for_processing_messages">Callbacks for Processing Messages</a></span></dt><dt><span class="sect1"><a href="#authentication_methods">Authentication Methods</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ice_connections">7. ICE Connections</a></span></dt><dd><dl><dt><span class="sect1"><a href="#opening_an_ice_connection">Opening an ICE Connection</a></span></dt><dt><span class="sect1"><a href="#listening_for_ice_connections">Listening for ICE Connections</a></span></dt><dt><span class="sect1"><a href="#host_based_authentication_for_ice_connec">Host Based Authentication for ICE Connections</a></span></dt><dt><span class="sect1"><a href="#accepting_ice_connections">Accepting ICE Connections</a></span></dt><dt><span class="sect1"><a href="#closing_ice_connections">Closing ICE Connections</a></span></dt><dt><span class="sect1"><a href="#connection_watch_procedures">Connection Watch Procedures</a></span></dt></dl></dd><dt><span class="chapter"><a href="#protocol_setup_and_shutdown">8. Protocol Setup and Shutdown</a></span></dt><dt><span class="chapter"><a href="#processing_messages">9. Processing Messages</a></span></dt><dt><span class="chapter"><a href="#ping">10. Ping</a></span></dt><dt><span class="chapter"><a href="#using_icelib_informational_functions">11. Using ICElib Informational Functions</a></span></dt><dt><span class="chapter"><a href="#ice_messages">12. ICE Messages</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sending_ice_messages">Sending ICE Messages</a></span></dt><dt><span class="sect1"><a href="#reading_ice_messages">Reading ICE Messages</a></span></dt></dl></dd><dt><span class="chapter"><a href="#error_handling">13. Error Handling</a></span></dt><dt><span class="chapter"><a href="#multithreading_support">14. Multi-Threading Support</a></span></dt><dt><span class="chapter"><a href="#miscellaneous_functions">15. Miscellaneous Functions</a></span></dt><dt><span class="chapter"><a href="#acknowledgements">16. Acknowledgements</a></span></dt><dt><span class="appendix"><a href="#authentication_utility_functions">A. Authentication Utility Functions</a></span></dt><dt><span class="appendix"><a href="#mit_magic_cookie_1_authentication">B. MIT-MAGIC-COOKIE-1 Authentication</a></span></dt></dl></div><div class="chapter" title="Chapter 1. Overview of ICE"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_ice"></a>Chapter 1. Overview of ICE</h2></div></div></div><p>
There are numerous possible inter-client protocols, with many similarities
and common needs - authentication, version negotiation, byte
order negotiation, and so on.
The Inter-Client Exchange (ICE) protocol is intended to provide a framework
for building such protocols, allowing them to make use of common negotiation
mechanisms and to be multiplexed over a single transport connection.
</p></div><div class="chapter" title="Chapter 2. The ICE Library - C Language Interface to ICE"><div class="titlepage"><div><div><h2 class="title"><a id="the_ice_library__c_language_interface_to"></a>Chapter 2. The ICE Library - C Language Interface to ICE</h2></div></div></div><p>
A client that wishes to utilize ICE must first register the protocols it
understands with the ICE library.  Each protocol is dynamically assigned
a major opcode ranging from 1-255 (two clients can use different
major opcodes for the same protocol).  The next step for the client is either
to open a connection with another client or to wait for connections made
by other clients.  Authentication may be required.  A client can both
initiate connections with other clients and be
waiting for clients to connect to itself (a nested session manager is an
example).  Once an ICE connection is established between the two clients, one
of the clients needs to initiate a
<code class="function">ProtocolSetup</code>
in order to
"activate" a given protocol.  Once the other client accepts the
<code class="function">ProtocolSetup</code>
(once again, authentication may be required), the
two clients are ready to start passing messages specific to that protocol to
each other.  Multiple protocols may be active on a single ICE connection.
Clients are responsible for notifying the ICE library when a protocol is no
longer active on an ICE connection, although ICE does not define how each
subprotocol triggers a protocol shutdown.
</p><p>
The ICE library utilizes callbacks to process incoming messages.  Using
callbacks allows
<code class="function">ProtocolSetup</code>
messages and authentication to happen
behind the scenes.  An additional benefit is that messages never need
to be buffered up by the library when the client blocks waiting for a
particular message.
</p></div><div class="chapter" title="Chapter 3. Intended Audience"><div class="titlepage"><div><div><h2 class="title"><a id="intended_audience"></a>Chapter 3. Intended Audience</h2></div></div></div><p>This document is intended primarily for implementors of protocol libraries
layered on top of ICE.  Typically, applications that wish to utilize ICE
will make calls into individual protocol libraries rather than directly
make calls into the ICE library.  However, some applications will have to
make some initial calls into the ICE library in order to accept ICE
connections (for example, a session manager accepting connections from
clients).  But in general, protocol libraries should be designed to hide
the inner details of ICE from applications.</p></div><div class="chapter" title="Chapter 4. Header Files and Library Name"><div class="titlepage"><div><div><h2 class="title"><a id="header_files_and_library_name"></a>Chapter 4. Header Files and Library Name</h2></div></div></div><p>The header file
&lt;<span class="symbol">X11/ICE/ICElib.h</span>&gt;
defines all of the ICElib data structures and function prototypes.
<code class="function">ICElib.h</code>
includes the header file
&lt;<span class="symbol">X11/ICE/ICE.h</span>&gt;,
which defines all of the ICElib constants.
Protocol libraries that need to read and write messages should include
the header file
&lt;<span class="symbol">X11/ICE/ICEmsg.h</span>&gt;.</p><p>Applications should link against ICElib using -lICE.</p></div><div class="chapter" title="Chapter 5. Note on Prefixes"><div class="titlepage"><div><div><h2 class="title"><a id="note_on_prefixes"></a>Chapter 5. Note on Prefixes</h2></div></div></div><p>The following name prefixes are used in the library to distinguish between
a client that initiates a
<code class="function">ProtocolSetup</code>
and a client that
responds with a
<code class="function">ProtocolReply</code></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="function">IcePo</code>
- Ice Protocol Originator</p></li><li class="listitem"><p><code class="function">IcePa</code>
- Ice Protocol Acceptor</p></li></ul></div></div><div class="chapter" title="Chapter 6. Protocol Registration"><div class="titlepage"><div><div><h2 class="title"><a id="protocol_registration"></a>Chapter 6. Protocol Registration</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#callbacks_for_processing_messages">Callbacks for Processing Messages</a></span></dt><dt><span class="sect1"><a href="#authentication_methods">Authentication Methods</a></span></dt></dl></div><p>
In order for two clients to exchange messages for a given protocol, each
side must register the protocol with the ICE library.  The purpose of
registration is for each side to obtain a major opcode for the protocol
and to provide callbacks for processing messages and handling authentication.
There are two separate registration functions:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
One to handle the side that does a
<code class="function">ProtocolSetup</code>
    </p></li><li class="listitem"><p>
One to handle the side that responds with a
<code class="function">ProtocolReply</code>
    </p></li></ul></div><p>
It is recommended that protocol registration occur before the two clients
establish an ICE connection.  If protocol registration occurs after an
ICE connection is created, there can be a brief interval of time in which a
<code class="function">ProtocolSetup</code>
is received, but the protocol is not registered.
If it is not possible to register a protocol before the creation of an
ICE connection, proper precautions should be taken to avoid the above race
condition.
</p><p>
The <code class="function">IceRegisterForProtocolSetup</code>
function should be called for the client that initiates a
<code class="function">ProtocolSetup</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfuncIceRegisterForProtocolSetup</strong>(</code></td><td><var class="pdparam"> *protocol_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *vendor</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *release</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *version_count</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *version_count</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *version_recs</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> auth_names</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **auth_names</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *auth_procs</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *io_error_proc</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *protocol_name</var></code>;<br /><code>char<var class="pdparam"> *vendor</var></code>;<br /><code>char<var class="pdparam"> *release</var></code>;<br /><code>int<var class="pdparam"> *version_count</var></code>;<br /><code>int<var class="pdparam"> *version_count</var></code>;<br /><code>IcePoVersionRec<var class="pdparam"> *version_recs</var></code>;<br /><code>int<var class="pdparam"> auth_names</var></code>;<br /><code>char<var class="pdparam"> **auth_names</var></code>;<br /><code>IcePoAuthProc<var class="pdparam"> *auth_procs</var></code>;<br /><code>IceIOErrorProc<var class="pdparam"> *io_error_proc</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>protocol_name</em></span></span></dt><dd><p>
A string specifying the name of the protocol to register.
      </p></dd><dt><span class="term"><span class="emphasis"><em>vendor</em></span></span></dt><dd><p>A vendor string with semantics specified by the protocol.</p></dd><dt><span class="term"><span class="emphasis"><em>release</em></span></span></dt><dd><p>A release string with semantics specified by the protocol.</p></dd><dt><span class="term"><span class="emphasis"><em>version_count</em></span></span></dt><dd><p>The number of different versions of the protocol supported.</p></dd><dt><span class="term"><span class="emphasis"><em>version_recs</em></span></span></dt><dd><p>List of versions and associated callbacks.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_count</em></span></span></dt><dd><p>The number of authentication methods supported.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_names</em></span></span></dt><dd><p>The list of authentication methods supported.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_procs</em></span></span></dt><dd><p>
The list of authentication callbacks, one for each authentication method.
      </p></dd><dt><span class="term"><span class="emphasis"><em>io_error_proc</em></span></span></dt><dd><p>IO error handler, or NULL.</p></dd></dl></div><p>
<code class="function">IceRegisterForProtocolSetup</code> returns the major
opcode reserved or -1 if an error occurred.  In order to actually activate
the protocol, the <code class="function">IceProtocolSetup</code>
function needs to be called with this major opcode.  Once the protocol is
activated, all messages for the protocol should be sent using this major
opcode.
</p><p>
A protocol library may support multiple versions of the same protocol.
The version_recs argument specifies a list of supported versions of the
protocol, which are prioritized in decreasing order of preference.
Each version record consists of a major and minor version of the protocol
as well as a callback to be used for processing incoming messages.
</p><div class="literallayout"><p><br />
typedef struct {<br />
	int major_version;<br />
	int minor_version;<br />
	IcePoProcessMsgProc process_msg_proc;<br />
} IcePoVersionRec;<br />
</p></div><p>The
<code class="function">IcePoProcessMsgProc</code>
callback is responsible for processing the set of messages that can be
received by the client that initiated the
<code class="function">ProtocolSetup</code>
For further information,
see
<a class="link" href="#callbacks_for_processing_messages" title="Callbacks for Processing Messages">
<a class="xref" href="#callbacks_for_processing_messages" title="Callbacks for Processing Messages">the section called “Callbacks for Processing Messages”</a></a>.</p><p>Authentication may be required before the protocol can become active.
The protocol library must register the authentication methods that it
supports with the ICE library.
The auth_names and auth_procs arguments are a list of authentication names
and callbacks that are  prioritized in decreasing order of preference.
For information on the
<code class="function">IcePoAuthProc</code>
callback, see
<a class="link" href="#authentication_methods" title="Authentication Methods">
<a class="xref" href="#authentication_methods" title="Authentication Methods">the section called “Authentication Methods”</a></a>
</p><p>The
<code class="function">IceIOErrorProc</code>
callback is invoked if the ICE connection unexpectedly breaks.
You should pass NULL for io_error_proc if not interested in being notified.
For further information,
<a class="link" href="#error_handling" title="Chapter 13. Error Handling">
<a class="xref" href="#error_handling" title="Chapter 13. Error Handling">Chapter 13, <em>Error Handling</em></a></a>
</p><p>The
<code class="function">IceRegisterForProtocolReply</code>
function should be called for the client that responds to a
<code class="function">ProtocolSetup</code>
with a
<code class="function">ProtocolReply</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Bool <strong>fsfuncIceRegisterForProtocolReply</strong>(</code></td><td><var class="pdparam"> *host_name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *host_name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>protocol_name</em></span></span></dt><dd><p>A string specifying the name of the protocol to register.</p></dd><dt><span class="term"><span class="emphasis"><em>vendor</em></span></span></dt><dd><p>A vendor string with semantics specified by the protocol.</p></dd><dt><span class="term"><span class="emphasis"><em>release</em></span></span></dt><dd><p>A release string with semantics specified by the protocol.</p></dd><dt><span class="term"><span class="emphasis"><em>version_count</em></span></span></dt><dd><p>The number of different versions of the protocol supported.</p></dd><dt><span class="term"><span class="emphasis"><em>version_recs</em></span></span></dt><dd><p>List of versions and associated callbacks.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_count</em></span></span></dt><dd><p>The number of authentication methods supported.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_names</em></span></span></dt><dd><p>The list of authentication methods supported.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_procs</em></span></span></dt><dd><p>The list of authentication callbacks, one for each authentication method.</p></dd><dt><span class="term"><span class="emphasis"><em>host_based_auth_proc</em></span></span></dt><dd><p>Host based authentication callback.</p></dd><dt><span class="term"><span class="emphasis"><em>protocol_setup_proc</em></span></span></dt><dd><p>A callback to be invoked when authentication has succeeded for a
<code class="function">ProtocolSetup</code>
but before the
<code class="function">ProtocolReply</code>
is sent.</p></dd><dt><span class="term"><span class="emphasis"><em>protocol_activate_proc</em></span></span></dt><dd><p>A callback to be invoked after the
<code class="function">ProtocolReply</code>
is sent.</p></dd><dt><span class="term"><span class="emphasis"><em>io_error_proc</em></span></span></dt><dd><p>IO error handler, or NULL.</p></dd></dl></div><p><code class="function">IceRegisterForProtocolReply</code>
returns the major opcode reserved or -1 if an error occurred.  The major
opcode should be used in all subsequent messages sent for this protocol.</p><p>A protocol library may support multiple versions of the same protocol.
The version_recs argument specifies a list of supported versions of the protocol,
which are prioritized in decreasing order of preference.
Each version record consists of a major and minor version of the protocol
as well as a callback to be used for processing incoming messages.</p><div class="literallayout"><p><br />
typedef struct {<br />
	int major_version;<br />
	int minor_version;<br />
	IcePaProcessMsgProc process_msg_proc;<br />
} IcePaVersionRec;<br />
</p></div><p>The
<code class="function">IcePaProcessMsgProc</code>
callback is responsible for processing the set of messages that can be
received by the client that accepted the
<code class="function">ProtocolSetup</code>
For further information,
see
<a class="link" href="#callbacks_for_processing_messages" title="Callbacks for Processing Messages">
<a class="xref" href="#callbacks_for_processing_messages" title="Callbacks for Processing Messages">the section called “Callbacks for Processing Messages”</a></a>
</p><p>Authentication may be required before the protocol can become active.
The protocol library must register the authentication methods that it
supports with the ICE library.
The auth_names and auth_procs arguments are a list of authentication names
and callbacks that are prioritized in decreasing order of preference.
For information on the
<code class="function">IcePaAuthProc</code>,
See
<a class="link" href="#authentication_methods" title="Authentication Methods">
<a class="xref" href="#authentication_methods" title="Authentication Methods">the section called “Authentication Methods”</a></a>

</p><p>If authentication fails and the client attempting to initiate
the
<code class="function">ProtocolSetup</code>
has not required authentication, the
<code class="function">IceHostBasedAuthProc</code>
callback is invoked with the host name of the originating client.
If the callback returns
<code class="function">True</code>
the
<code class="function">ProtocolSetup</code>
will succeed, even though the original
authentication failed.
Note that authentication can effectively be disabled by registering an
<code class="function">IceHostBasedAuthProc</code>
which always returns
<code class="function">True</code>
If no host based
authentication is allowed, you should pass NULL for host_based_auth_proc.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Bool <strong>fsfuncHostBasedAuthProc</strong>(</code></td><td><var class="pdparam"> *host_name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *host_name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>protocol_name</em></span></span></dt><dd><p>The host name of the client that sent the <code class="function">ProtocolSetup</code></p></dd></dl></div><p>The host_name argument is a string of the form <span class="emphasis"><em>protocol</em></span>/<span class="emphasis"><em>hostname</em></span>,
where <span class="emphasis"><em>protocol</em></span> is one of {tcp, decnet, local}.</p><p>Because
<code class="function">ProtocolSetup</code>
messages and authentication happen behind the scenes
via callbacks, the protocol library needs some way of being notified when the
<code class="function">ProtocolSetup</code>
has completed.
This occurs in two phases.
In the first phase, the
<code class="function">IceProtocolSetupProc</code>
callback is invoked after authentication has
successfully completed but before the ICE library sends a
<code class="function">ProtocolReply</code>
Any resources required for this protocol should be allocated at this time.
If the
<code class="function">IceProtocolSetupProc</code>
returns a successful status, the ICE library will
send the
<code class="function">ProtocolReply</code>
and then invoke the
<code class="function">IceProtocolActivateProc</code>
callback.  Otherwise, an error will be sent to the
other client in response to the
<code class="function">ProtocolSetup</code></p><p>The
<code class="function">IceProtocolActivateProc</code>
is an optional callback and should be registered only if the protocol
library intends to generate a message immediately following the
<code class="function">ProtocolReply</code>
You should pass NULL for protocol_activate_proc if not interested
in this callback.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status <strong>fsfuncProtocolSetupProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> major_version</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> minor_version</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *vendor</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *release</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *client_data_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **failure_reason_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> major_version</var></code>;<br /><code>int<var class="pdparam"> minor_version</var></code>;<br /><code>char<var class="pdparam"> *vendor</var></code>;<br /><code>char<var class="pdparam"> *release</var></code>;<br /><code>IcePointer<var class="pdparam"> *client_data_ret</var></code>;<br /><code>char<var class="pdparam"> **failure_reason_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>protocol_name</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>major_version</em></span></span></dt><dd><p>The major version of the protocol.</p></dd><dt><span class="term"><span class="emphasis"><em>minor_version</em></span></span></dt><dd><p>The minor version of the protocol.</p></dd><dt><span class="term"><span class="emphasis"><em>vendor</em></span></span></dt><dd><p>The vendor string registered by the protocol originator.</p></dd><dt><span class="term"><span class="emphasis"><em>release</em></span></span></dt><dd><p>The release string registered by the protocol originator.</p></dd><dt><span class="term"><span class="emphasis"><em>client_data_ret</em></span></span></dt><dd><p>Client data to be set by callback.</p></dd><dt><span class="term"><span class="emphasis"><em>failure_reason_ret</em></span></span></dt><dd><p>Failure reason returned.</p></dd></dl></div><p>The pointer stored in the client_data_ret argument will be passed
to the
<code class="function">IcePaProcessMsgProc</code>
callback whenever a message has arrived for this protocol on the
ICE connection.</p><p>The vendor and release strings should be freed with
<code class="function">free</code>
when they are no longer needed.</p><p>If a failure occurs, the
<code class="function">IceProtocolSetupProc</code>
should return a zero status as well as allocate and return a failure
reason string in failure_reason_ret.
The ICE library will be responsible for freeing this memory.</p><p>The
<code class="function">IceProtocolActivateProc</code>
callback is defined as follows:</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncProtocolActivateProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>
The client data set in the <code class="function">IceProtocolSetupProc</code> callback.
    </p></dd></dl></div><p>The
<code class="function">IceIOErrorProc</code>
callback is invoked if the ICE connection unexpectedly breaks.
You should pass NULL for io_error_proc if not interested in being notified.
For further information,
see
<a class="link" href="#error_handling" title="Chapter 13. Error Handling">
<a class="xref" href="#error_handling" title="Chapter 13. Error Handling">Chapter 13, <em>Error Handling</em></a></a>
</p><div class="sect1" title="Callbacks for Processing Messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="callbacks_for_processing_messages"></a>Callbacks for Processing Messages</h2></div></div></div><p>When an application detects that there is new data to read on an ICE
connection (via
<code class="function">select</code>
it calls the
<code class="function">IceProcessMessages</code>
function
<a class="link" href="#processing_messages" title="Chapter 9. Processing Messages">
<a class="xref" href="#processing_messages" title="Chapter 9. Processing Messages">Chapter 9, <em>Processing Messages</em></a></a>.

When
<code class="function">IceProcessMessages</code>
reads an ICE message header with a major opcode other than
zero (reserved for the ICE protocol), it needs to call a function that will
read the rest of the message, unpack it, and process it accordingly.</p><p>If the message arrives at the client that initiated the
<code class="function">ProtocolSetup</code>
the
<code class="function">IcePoProcessMsgProc</code>
callback is invoked.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncPoProcessMsgProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> length</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> swap</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *reply_wait</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *reply_ready_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;<br /><code>int<var class="pdparam"> opcode</var></code>;<br /><code>unsigned long<var class="pdparam"> length</var></code>;<br /><code>Bool<var class="pdparam"> swap</var></code>;<br /><code>IceReplyWaitInfo<var class="pdparam"> *reply_wait</var></code>;<br /><code>Bool<var class="pdparam"> *reply_ready_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>Client data associated with this protocol on the ICE connection.</p></dd><dt><span class="term"><span class="emphasis"><em>opcode</em></span></span></dt><dd><p>The minor opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>length</em></span></span></dt><dd><p>The length (in 8-byte units) of the message beyond the ICE header.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>A flag that indicates if byte swapping is necessary.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_wait</em></span></span></dt><dd><p>Indicates if the invoking client is waiting for a reply.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_ready_ret</em></span></span></dt><dd><p>If set to
<code class="function">True</code>
a reply is ready.</p></dd></dl></div><p>If the message arrives at the client that accepted the
<code class="function">ProtocolSetup</code>
the
<code class="function">IcePaProcessMsgProc</code>
callback is invoked.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncIcePaProcessMsgProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> length</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> swap</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;<br /><code>int<var class="pdparam"> opcode</var></code>;<br /><code>unsigned long<var class="pdparam"> length</var></code>;<br /><code>Bool<var class="pdparam"> swap</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>Client data associated with this protocol on the ICE connection.</p></dd><dt><span class="term"><span class="emphasis"><em>opcode</em></span></span></dt><dd><p>The minor opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>length</em></span></span></dt><dd><p>The length (in 8-byte units) of the message beyond the ICE header.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>A flag that indicates if byte swapping is necessary.</p></dd></dl></div><p>In order to read the message, both of these callbacks should use the
macros defined for this purpose (see
<a class="link" href="#reading_ice_messages" title="Reading ICE Messages">
<a class="xref" href="#reading_ice_messages" title="Reading ICE Messages">the section called “Reading ICE Messages”</a></a>.).
Note that byte swapping may be necessary.
As a convenience, the length field in the ICE header will be swapped by ICElib
if necessary.</p><p>In both of these callbacks, the client_data argument is a pointer to client
data that was registered at
<code class="function">ProtocolSetup</code>
time.
In the case of
<code class="function">IcePoProcessMsgProc</code>
the client data was set in the call to
<code class="function">IceProtocolSetup</code>
In the case of
<code class="function">IcePaProcessMsgProc</code>
the client data was set in the
<code class="function">IceProtocolSetupProc</code>
callback.</p><p>The
<code class="function">IcePoProcessMsgProc</code>
callback needs to check the reply_wait argument.
If reply_wait is NULL ,
the ICE library expects the function to
pass the message to the client via a callback.
For example, if this is a Session Management "Save Yourself" message,
this function should notify the client of the "Save Yourself" via a callback.
The details of how such a callback would be defined
are implementation-dependent.</p><p>However, if reply_wait is not NULL ,
then the client is waiting for
a reply or an error for a message it previously sent.
The reply_wait is of type
<code class="function">IceReplyWaitInfo</code></p><div class="literallayout"><p><br />
typedef struct {<br />
	unsigned long sequence_of_request;<br />
	int major_opcode_of_request;<br />
	int minor_opcode_of_request;<br />
	IcePointer reply;<br />
} IceReplyWaitInfo;<br />
</p></div><p><code class="function">IceReplyWaitInfo</code>
contains the major/minor opcodes and sequence number of
the message for which a reply is being awaited.
It also contains a pointer to the reply message to be filled in
(the protocol library should cast this
<code class="function">IcePointer</code>
to the appropriate reply type).
In most cases, the reply will have some fixed-size part, and the client waiting
for the reply will have provided a pointer to a structure to hold
this fixed-size data.  If there is variable-length data, it would be
expected that the
<code class="function">IcePoProcessMsgProc</code>
callback will have to allocate additional
memory and store pointer(s) to that memory in the fixed-size
structure.  If the entire data is variable length (for example., a single
variable-length string), then the client waiting for the reply would probably
just pass a pointer to fixed-size space to hold a pointer, and the
<code class="function">IcePoProcessMsgProc</code>
callback would allocate the storage and store the pointer.
It is the responsibility of the client receiving the reply to
free any memory allocated on its behalf.</p><p>If reply_wait is not NULL and
<code class="function">IcePoProcessMsgProc</code>
has a reply or error to return in response to this reply_wait
(that is, no callback was generated), then the reply_ready_ret argument
should be set to
<code class="function">True</code>
Note that an error should only be returned
if it corresponds to the reply being waited for.  Otherwise, the
<code class="function">IcePoProcessMsgProc</code>
should either handle the error internally or invoke an error handler
for its library.</p><p>If reply_wait is NULL,
then care must be taken not to store any value in reply_ready_ret,
because this pointer may also be NULL.</p><p>The
<code class="function">IcePaProcessMsgProc</code>
callback, on the other hand, should always pass
the message to the client via a callback.  For example, if this is a Session
Management "Interact Request" message, this function should notify the
client of the "Interact Request" via a callback.</p><p>The reason the
<code class="function">IcePaProcessMsgProc</code>
callback does not have a reply_wait, like
<code class="function">IcePoProcessMsgProc</code>
does, is because a process that is acting as
a server should never block for a reply (infinite blocking can
occur if the connecting client does not act properly, denying access
to other clients).</p></div><div class="sect1" title="Authentication Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="authentication_methods"></a>Authentication Methods</h2></div></div></div><p>As already stated, a protocol library must register the authentication
methods that it supports with the ICE library.  For each authentication
method, there are two callbacks that may be registered:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
One to handle the side that initiates a <code class="function">ProtocolSetup</code>
    </p></li><li class="listitem"><p>
One to handle the side that accepts or rejects this request
    </p></li></ul></div><p><code class="function">IcePoAuthProc</code>
is the callback invoked for the client that initiated the
<code class="function">ProtocolSetup</code>
This callback must be able to respond
to the initial "Authentication Required" message or subsequent
"Authentication Next Phase" messages sent by the other client.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IcePoAuthStatus <strong>fsfuncIcePoAuthStatus </strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> opcode</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;<br /><code>int<var class="pdparam"> opcode</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_state_ptr</em></span></span></dt><dd><p>A pointer to state for use by the authentication callback procedure.</p></dd><dt><span class="term"><span class="emphasis"><em>clean_up</em></span></span></dt><dd><p>If
<code class="function">True</code>
authentication is over, and the function
should clean up any state it was maintaining.  The
last 6 arguments should be ignored.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>If
<code class="function">True</code>
the auth_data may have to be byte swapped
(depending on its contents).</p></dd><dt><span class="term"><span class="emphasis"><em>auth_datalen</em></span></span></dt><dd><p>The length (in bytes) of the authenticator data.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_data</em></span></span></dt><dd><p>The data from the authenticator.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_datalen_ret</em></span></span></dt><dd><p>The length (in bytes) of the reply data returned.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_data_ret</em></span></span></dt><dd><p>The reply data returned.</p></dd><dt><span class="term"><span class="emphasis"><em>error_string_ret</em></span></span></dt><dd><p>If the authentication procedure encounters an error during
authentication, it should allocate and return
an error string.</p></dd></dl></div><p>Authentication may require several phases, depending on the authentication
method.  As a result, the
<code class="function">IcePoAuthProc</code>
may be called more than once when authenticating a client, and
some state will have to be maintained between each invocation.
At the start of each
<code class="function">ProtocolSetup</code>
*auth_state_ptr is NULL,
and the function should initialize its state and set
this pointer.  In subsequent invocations of the callback, the pointer
should be used to get at any state previously stored by the callback.</p><p>If needed, the network ID of the client accepting the
<code class="function">ProtocolSetup</code>
can be obtained by calling the
<code class="function">IceConnectionString</code>
function.</p><p>ICElib will be responsible for freeing the reply_data_ret and
error_string_ret pointers with
<code class="function">free</code></p><p>The auth_data pointer may point to a volatile block of memory.
If the data must be kept beyond this invocation of the callback, be sure
to make a copy of it.</p><p>The
<code class="function">IcePoAuthProc</code>
should return one of four values:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="function">IcePoAuthHaveReply</code>
- a reply is available.</p></li><li class="listitem"><p><code class="function">IcePoAuthRejected</code>
- authentication rejected.</p></li><li class="listitem"><p><code class="function">IcePoAuthFailed</code>
- authentication failed.</p></li><li class="listitem"><p><code class="function">IcePoAuthDoneCleanup</code>
- done cleaning up.</p></li></ul></div><p><code class="function">IcePaAuthProc</code>
is the callback invoked for the client that received the
<code class="function">ProtocolSetup</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IcePoAuthStatus <strong>fsfuncPoAuthStatus </strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *auth_state_ptr</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> swap</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> auth_datalen</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> auth_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *reply_datalen_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *reply_data_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **error_string_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> *auth_state_ptr</var></code>;<br /><code>Bool<var class="pdparam"> swap</var></code>;<br /><code>int<var class="pdparam"> auth_datalen</var></code>;<br /><code>IcePointer<var class="pdparam"> auth_data</var></code>;<br /><code>int<var class="pdparam"> *reply_datalen_ret</var></code>;<br /><code>IcePointer<var class="pdparam"> *reply_data_ret</var></code>;<br /><code>char<var class="pdparam"> **error_string_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_state_ptr</em></span></span></dt><dd><p>A pointer to state for use by the authentication callback procedure.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>If
<code class="function">True</code>
auth_data may have to be byte swapped
(depending on its contents).</p></dd><dt><span class="term"><span class="emphasis"><em>auth_datalen</em></span></span></dt><dd><p>The length (in bytes) of the protocol originator authentication data.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_data</em></span></span></dt><dd><p>The authentication data from the protocol originator.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_datalen_ret</em></span></span></dt><dd><p>The length of the authentication data returned.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_data_ret</em></span></span></dt><dd><p>The authentication data returned.</p></dd><dt><span class="term"><span class="emphasis"><em>error_string_ret</em></span></span></dt><dd><p>If authentication is rejected or fails, an error
string is returned.</p></dd></dl></div><p>Authentication may require several phases, depending on the authentication
method.  As a result, the
<code class="function">IcePaAuthProc</code>
may be called more than once when authenticating a client, and
some state will have to be maintained between each invocation.
At the start of each
<code class="function">ProtocolSetup</code>
auth_datalen is zero,
*auth_state_ptr is NULL,
and the function should initialize its state and set
this pointer.  In subsequent invocations of the callback, the pointer
should be used to get at any state previously stored by the callback.</p><p>If needed, the network ID of the client accepting the
<code class="function">ProtocolSetup</code>
can be obtained by calling the
<code class="function">IceConnectionString</code>
function.</p><p>The auth_data pointer may point to a volatile block of memory.
If the data must be kept beyond this invocation of the callback, be sure
to make a copy of it.</p><p>ICElib will be responsible for transmitting and freeing the reply_data_ret and
error_string_ret pointers with
<code class="function">free</code></p><p>
The <code class="function">IcePaAuthProc</code> should return one of four values:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="function">IcePaAuthContinue</code> - continue (or start) authentication.
    </p></li><li class="listitem"><p>
<code class="function">IcePaAuthAccepted</code> - authentication accepted.
    </p></li><li class="listitem"><p>
<code class="function">IcePaAuthRejected</code> - authentication rejected.
    </p></li><li class="listitem"><p>
<code class="function">IcePaAuthFailed</code> - authentication failed.
    </p></li></ul></div></div></div><div class="chapter" title="Chapter 7. ICE Connections"><div class="titlepage"><div><div><h2 class="title"><a id="ice_connections"></a>Chapter 7. ICE Connections</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#opening_an_ice_connection">Opening an ICE Connection</a></span></dt><dt><span class="sect1"><a href="#listening_for_ice_connections">Listening for ICE Connections</a></span></dt><dt><span class="sect1"><a href="#host_based_authentication_for_ice_connec">Host Based Authentication for ICE Connections</a></span></dt><dt><span class="sect1"><a href="#accepting_ice_connections">Accepting ICE Connections</a></span></dt><dt><span class="sect1"><a href="#closing_ice_connections">Closing ICE Connections</a></span></dt><dt><span class="sect1"><a href="#connection_watch_procedures">Connection Watch Procedures</a></span></dt></dl></div><p>
In order for two clients to establish an ICE connection, one client has to be
waiting for connections, and the other client has to initiate the connection.
Most clients will initiate connections, so we discuss that first.
</p><div class="sect1" title="Opening an ICE Connection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="opening_an_ice_connection"></a>Opening an ICE Connection</h2></div></div></div><p>
To open an ICE connection with another client (that is, waiting
for connections), use <code class="function">IceOpenConnection</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceConn <strong>fsfuncIceOpenConnection</strong>(</code></td><td><var class="pdparam"> *network_ids_list</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> context</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> must_authenticate</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> major_opcode_check</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> error_length</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *error_string_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *network_ids_list</var></code>;<br /><code>IcePointer<var class="pdparam"> context</var></code>;<br /><code>Bool<var class="pdparam"> must_authenticate</var></code>;<br /><code>int<var class="pdparam"> major_opcode_check</var></code>;<br /><code>int<var class="pdparam"> error_length</var></code>;<br /><code>char<var class="pdparam"> *error_string_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>network_ids_list</em></span></span></dt><dd><p>
Specifies the network ID(s) of the other client.
      </p></dd><dt><span class="term"><span class="emphasis"><em>context</em></span></span></dt><dd><p>
A pointer to an opaque object or NULL.  Used to determine if an
ICE connection can be shared (see below).
      </p></dd><dt><span class="term"><span class="emphasis"><em>must_authenticate</em></span></span></dt><dd><p>
If <code class="function">True</code> the other client may not bypass authentication.
      </p></dd><dt><span class="term"><span class="emphasis"><em>major_opcode_check</em></span></span></dt><dd><p>
Used to force a new ICE connection to be created (see below).
      </p></dd><dt><span class="term"><span class="emphasis"><em>error_length</em></span></span></dt><dd><p>Length of the error_string_ret argument passed in.</p></dd><dt><span class="term"><span class="emphasis"><em>error_string_ret</em></span></span></dt><dd><p>
Returns a null-terminated error message, if any.  The error_string_ret
argument points to user supplied memory.  No more than error_length bytes
are used.
      </p></dd></dl></div><p>
<code class="function">IceOpenConnection</code>
returns an opaque ICE connection object if it succeeds;
otherwise, it returns NULL.
</p><p>
The network_ids_list argument contains a list of network IDs separated
by commas.  An attempt will be made to use the first network ID.  If
that fails, an attempt will be made using the second network ID, and so on.
Each network ID has the following format:
</p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /><col align="center" class="c3" /></colgroup><tbody><tr><td align="left"> </td><td align="left">tcp/&lt;hostname&gt;:&lt;portnumber&gt;</td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left">decnet/&lt;hostname&gt;::&lt;objname&gt;</td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left">local/&lt;hostname&gt;:&lt;path&gt;</td><td align="left"> </td></tr></tbody></table></div><p>Most protocol libraries will have some sort of open function that should
internally make a call into
<code class="function">IceOpenConnection</code>
When
<code class="function">IceOpenConnection</code>
is called, it may be possible to use a previously opened ICE connection (if
the target client is the same).  However, there are cases in which shared
ICE connections are not desired.</p><p>The context argument is used to determine if an ICE connection can
be shared.
If context is NULL,
then the caller is always willing to share the connection.
If context is not NULL,
then the caller is not willing to use a previously opened ICE connection
that has a different non-NULL context associated with it.</p><p>In addition, if major_opcode_check contains a nonzero major opcode value,
a previously created ICE connection will be used only if the major opcode
is not active on the connection.  This can be used to force multiple ICE
connections between two clients for the same protocol.</p><p>Any authentication requirements are handled internally by the ICE library.
The method by which the authentication data is obtained
is implementation-dependent.
  <sup>[<a id="idp3147504" href="#ftn.idp3147504" class="footnote">1</a>]</sup> </p><p>After
<code class="function">IceOpenConnection</code>
is called, the client is ready to send a
<code class="function">ProtocolSetup</code>
(provided that
<code class="function">IceRegisterForProtocolSetup</code>
was called) or receive a
<code class="function">ProtocolSetup</code>
(provided that
<code class="function">IceRegisterForProtocolReply</code>
was called).</p></div><div class="sect1" title="Listening for ICE Connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="listening_for_ice_connections"></a>Listening for ICE Connections</h2></div></div></div><p>Clients wishing to accept ICE connections must first call
<code class="function">IceListenForConnections</code>
or
<code class="function">IceListenForWellKnownConnections</code>
so that they can listen for connections.  A list of opaque "listen" objects are
returned, one for each type of transport method that is available
(for example, Unix Domain, TCP, DECnet, and so on).</p><p>Normally clients will let ICElib allocate an available name in each
transport and return listen objects.  Such a client will then use
<code class="function">IceComposeNetworkIdList</code>
to extract the chosen names and make them
available to other clients for opening the connection.  In certain
cases it may be necessary for a client to listen for connections
on pre-arranged transport object names.  Such a client may use
<code class="function">IceListenForWellKnownConnections</code>
to specify the names for the listen objects.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status <strong>fsfuncIceListenForConnections</strong>(</code></td><td><var class="pdparam"> *count_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **listen_objs_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> error_length</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *error_string_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>int<var class="pdparam"> *count_ret</var></code>;<br /><code>IceListenObj<var class="pdparam"> **listen_objs_ret</var></code>;<br /><code>int<var class="pdparam"> error_length</var></code>;<br /><code>char<var class="pdparam"> *error_string_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>count_ret</em></span></span></dt><dd><p>Returns the number of listen objects created.</p></dd><dt><span class="term"><span class="emphasis"><em>listen_objs_ret</em></span></span></dt><dd><p>Returns a list of pointers to opaque listen objects.</p></dd><dt><span class="term"><span class="emphasis"><em>error_length</em></span></span></dt><dd><p>The length of the error_string_ret argument passed in.</p></dd><dt><span class="term"><span class="emphasis"><em>error_string_ret</em></span></span></dt><dd><p>Returns a null-terminated error message, if any.
The error_string_ret points to user supplied memory.
No more than error_length bytes are used.</p></dd></dl></div><p>The return value of
<code class="function">IceListenForConnections</code>
is zero for failure and a positive value for success.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status <strong>fsfuncIceListenForWellKnownConnections</strong>(</code></td><td><var class="pdparam"> *port_id</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *count_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **listen_objs_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> error_length</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *error_string_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *port_id</var></code>;<br /><code>int<var class="pdparam"> *count_ret</var></code>;<br /><code>IceListenObj<var class="pdparam"> **listen_objs_ret</var></code>;<br /><code>int<var class="pdparam"> error_length</var></code>;<br /><code>char<var class="pdparam"> *error_string_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>port_id</em></span></span></dt><dd><p>
Specifies the port identification for the address(es) to be opened.  The
value must not contain the slash ("/"&gt; or comma (".") character; thse are
reserved for future use.
      </p></dd><dt><span class="term"><span class="emphasis"><em>count_ret</em></span></span></dt><dd><p>Returns the number of listen objects created.</p></dd><dt><span class="term"><span class="emphasis"><em>listen_objs_ret</em></span></span></dt><dd><p>
Returns a list of pointers to opaque listen objects.
      </p></dd><dt><span class="term"><span class="emphasis"><em>listen_objs_ret</em></span></span></dt><dd><p>
Returns a list of pointers to opaque listen objects.
      </p></dd><dt><span class="term"><span class="emphasis"><em>error_length</em></span></span></dt><dd><p>
The length of the error_string_ret argument passed in.
      </p></dd><dt><span class="term"><span class="emphasis"><em>error_string_ret</em></span></span></dt><dd><p>
Returns a null-terminated error message, if any.  The error_string_ret
points to user supplied memory.  No more than error_length bytes are used.
      </p></dd></dl></div><p>
<code class="function">IceListenForWellKnownConnections</code> constructs a list
of network IDs by prepending each known transport to port_id and then
attempts to create listen objects for the result.  Port_id is the portnumber,
objname, or path portion of the ICE network ID. If a listen object for
a particular network ID cannot be created the network ID is ignored.
If no listen objects are created
<code class="function">IceListenForWellKnownConnections</code>
returns failure.
</p><p>
The return value of <code class="function">IceListenForWellKnownConnections</code>
is zero for failure and a positive value for success.
</p><p>
To close and free the listen objects, use
<code class="function">IceFreeListenObjs</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncIceFreeListenObjs</strong>(</code></td><td><var class="pdparam"> count</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *listen_objs</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>int<var class="pdparam"> count</var></code>;<br /><code>IceListenObj<var class="pdparam"> *listen_objs</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>count</em></span></span></dt><dd><p>The number of listen objects.</p></dd><dt><span class="term"><span class="emphasis"><em>listen_objs</em></span></span></dt><dd><p>The listen objects.</p></dd></dl></div><p>
To detect a new connection on a listen object, use
<code class="function">select</code> on the descriptor associated with
the listen object.
</p><p>
To obtain the descriptor, use
<code class="function">IceGetListenConnectionNumber</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfuncIceGetListenConnectionNumber</strong>(</code></td><td><var class="pdparam"> *listen_objs</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceListenObj<var class="pdparam"> *listen_objs</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>listen_obj</em></span></span></dt><dd><p>The listen objects.</p></dd></dl></div><p>
To obtain the network ID string associated with a listen object, use
<code class="function">IceGetListenConnectionString</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char <strong>fsfuncIceGetListenConnectionString</strong>(</code></td><td><var class="pdparam"> listen_obj</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceListenObj<var class="pdparam"> listen_obj</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>listen_obj</em></span></span></dt><dd><p>The listen objects.</p></dd></dl></div><p>A network ID has the following format:</p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /><col align="center" class="c3" /></colgroup><tbody><tr><td align="left"> </td><td align="left">tcp/&lt;hostname&gt;:&lt;portnumber&gt;</td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left">decnet/&lt;hostname&gt;::&lt;objname&gt;</td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left">local/&lt;hostname&gt;:&lt;path&gt;</td><td align="left"> </td></tr></tbody></table></div><p>
To compose a string containing a list of network IDs separated by commas
(the format recognized by <code class="function">IceOpenConnection</code>
use <code class="function">IceComposeNetworkIdList</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char <strong>fsfuncIceComposeNetworkIdList</strong>(</code></td><td><var class="pdparam"> count</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *listen_objs</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>int<var class="pdparam"> count</var></code>;<br /><code>IceListenObj<var class="pdparam"> *listen_objs</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>count</em></span></span></dt><dd><p>The number of listen objects.</p></dd><dt><span class="term"><span class="emphasis"><em>listen_objs</em></span></span></dt><dd><p>The listen objects.</p></dd></dl></div></div><div class="sect1" title="Host Based Authentication for ICE Connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="host_based_authentication_for_ice_connec"></a>Host Based Authentication for ICE Connections</h2></div></div></div><p>
If authentication fails when a client attempts to open an
ICE connection and the initiating client has not required authentication,
a host based authentication procedure may be invoked to provide
a last chance for the client to connect.  Each listen object has such a
callback associated with it, and this callback is set using the
<code class="function">IceSetHostBasedAuthProc</code>
function.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncIceSetHostBasedAuthProc</strong>(</code></td><td><var class="pdparam"> listen_obj</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> host_based_auth_proc</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceListenObj<var class="pdparam"> listen_obj</var></code>;<br /><code>IceHostBasedAuthProc<var class="pdparam"> host_based_auth_proc</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>IceListenObj</em></span></span></dt><dd><p>The listen object.</p></dd><dt><span class="term"><span class="emphasis"><em>host_based_auth_proc</em></span></span></dt><dd><p>The host based authentication procedure.</p></dd></dl></div><p>
By default, each listen object has no host based authentication procedure
associated with it.  Passing NULL for host_based_auth_proc turns off
host based authentication if it was previously set.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Bool <strong>fsfuncHostBasedAuthProc</strong>(</code></td><td><var class="pdparam"> *host_name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *host_name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>host_name</em></span></span></dt><dd><p>
The host name of the client that tried to open an ICE connection.
      </p></dd></dl></div><p>
The host_name argument is a string in the form
<span class="emphasis"><em>protocol</em></span>/
<span class="emphasis"><em>hostname</em></span>,
where <span class="emphasis"><em>protocol</em></span> is one of
{tcp, decnet, local}.
</p><p>
If <code class="function">IceHostBasedAuthProc</code> returns
<code class="function">True</code>
access will be granted, even though the original authentication failed.
Note that authentication can effectively be disabled by registering an
<code class="function">IceHostBasedAuthProc</code>
which always returns <code class="function">True</code>
</p><p>
Host based authentication is also allowed at
<code class="function">ProtocolSetup</code> time.
The callback is specified in the
<code class="function">IceRegisterForProtocolReply</code>
function (see
<a class="link" href="#protocol_registration" title="Chapter 6. Protocol Registration">
<a class="xref" href="#protocol_registration" title="Chapter 6. Protocol Registration">Chapter 6, <em>Protocol Registration</em></a></a>).
</p></div><div class="sect1" title="Accepting ICE Connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="accepting_ice_connections"></a>Accepting ICE Connections</h2></div></div></div><p>
After a connection attempt is detected on a listen object returned by
<code class="function">IceListenForConnections</code>
you should call <code class="function">IceAcceptConnection</code>
This returns a new opaque ICE connection object.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceConn <strong>fsfuncIceAcceptConnection</strong>(</code></td><td><var class="pdparam"> listen_obj</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *status_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceListenObj<var class="pdparam"> listen_obj</var></code>;<br /><code>IceAcceptStatus<var class="pdparam"> *status_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>listen_obj</em></span></span></dt><dd><p>The listen object on which a new connection was detected.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>status_ret</em></span></span></dt><dd><p>Return status information.</p></dd></dl></div><p>The status_ret argument is set to one of the following values:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="function">IceAcceptSuccess</code>
- the accept operation succeeded,
and the function returns a new connection object.</p></li><li class="listitem"><p><code class="function">IceAcceptFailure</code>
- the accept operation failed, and the function returns NULL.</p></li><li class="listitem"><p><code class="function">IceAcceptBadMalloc</code>
- a memory allocation failed, and the function returns NULL.</p></li></ul></div><p>In general, to detect new connections, you should call
<code class="function">select</code>
on the file descriptors associated with the listen objects.
When a new connection is detected, the
<code class="function">IceAcceptConnection</code>
function should be called.
<code class="function">IceAcceptConnection</code>
may return a new ICE connection that is in a pending state.  This is because
before the connection can become valid, authentication may be necessary.
Because the ICE library cannot block and wait for the connection to
become valid (infinite blocking can occur if the connecting client
does not act properly), the application must wait for the connection status
to become valid.</p><p>The following pseudo-code demonstrates how connections are accepted:</p><pre class="literallayout">
new_ice_conn = IceAcceptConnection (listen_obj, &amp;accept_status);
if (accept_status != IceAcceptSuccess)
{
     close the file descriptor and return
}

status = IceConnectionStatus (new_ice_conn);
time_start = time_now;

while (status == IceConnectPending)
{
     select() on {new_ice_conn, all open connections}

     for (each ice_conn in the list of open connections)
          if (data ready on ice_conn)
          {
               status = IceProcessMessages (ice_conn, NULL, NULL);
               if (status == IceProcessMessagesIOError)
                    IceCloseConnection(ice_conn);
          }
     if data ready on new_ice_conn
     {
          /*
          * IceProcessMessages is called until the connection
          * is non-pending.  Doing so handles the connection
          * setup request and any authentication requirements.
          */

          IceProcessMessages ( new_ice_conn, NULL, NULL);
          status = IceConnectionStatus (new_ice_conn);
     }
     else
     {
          if (time_now - time_start &gt; MAX_WAIT_TIME)
               status = IceConnectRejected;
     }
}

if (status == IceConnectAccepted)
{
     Add new_ice_conn to the list of open connections
}
else
{
     IceCloseConnection
     new_ice_conn
}
</pre><p>After
<code class="function">IceAcceptConnection</code>
is called and the connection has been
validated, the client is ready to receive a
<code class="function">ProtocolSetup</code>
(provided
that
<code class="function">IceRegisterForProtocolReply</code>
was called) or send a
<code class="function">ProtocolSetup</code>
(provided that
<code class="function">IceRegisterForProtocolSetup</code>
was called).</p></div><div class="sect1" title="Closing ICE Connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="closing_ice_connections"></a>Closing ICE Connections</h2></div></div></div><p>To close an ICE connection created with
<code class="function">IceOpenConnection</code>
or
<code class="function">IceAcceptConnection</code>
use
<code class="function">IceCloseConnection</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceCloseStatus <strong>fsfuncIceCloseConnection</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection to close.</p></dd></dl></div><p>To actually close an ICE connection, the following conditions
must be met:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <span class="emphasis"><em>open reference count</em></span> must have reached zero on this ICE connection.
When
<code class="function">IceOpenConnection</code>
is called, it tries to use a previously opened
ICE connection.  If it is able to use an existing connection, it increments
the open reference count on the connection by one.
So, to close an ICE connection, each call to
<code class="function">IceOpenConnection</code>
must be matched with a call to
<code class="function">IceCloseConnection</code>
The connection can be closed only
on the last call to
<code class="function">IceCloseConnection</code></p></li><li class="listitem"><p>The <span class="emphasis"><em>active protocol count</em></span> must have reached zero.  Each time a
<code class="function">ProtocolSetup</code>
succeeds on the connection, the active protocol count
is incremented by one.  When the client no longer expects to use the
protocol on the connection, the
<code class="function">IceProtocolShutdown</code>
function should be called, which decrements the active protocol count
by one (see
<a class="link" href="#protocol_setup_and_shutdown" title="Chapter 8. Protocol Setup and Shutdown">
<a class="xref" href="#protocol_setup_and_shutdown" title="Chapter 8. Protocol Setup and Shutdown">Chapter 8, <em>Protocol Setup and Shutdown</em></a></a>).
</p></li><li class="listitem"><p>If shutdown negotiation is enabled on the connection, the client on the other
side of the ICE connection must agree to have the connection closed.</p><p><code class="function">IceCloseConnection</code>
returns one of the following values:</p></li><li class="listitem"><p><code class="function">IceClosedNow</code>
- the ICE connection was closed at this time.  The watch procedures were
invoked and the connection was freed.</p></li><li class="listitem"><p><code class="function">IceClosedASAP</code>
- an IO error had occurred on the connection, but
<code class="function">IceCloseConnection</code>
is being called within a nested
<code class="function">IceProcessMessages</code>
The watch procedures have been invoked at this time, but the connection
will be freed as soon as possible (when the nesting level reaches zero and
<code class="function">IceProcessMessages</code>
returns a status of
<code class="function">IceProcessMessagesConnectionClosed</code></p></li><li class="listitem"><p><code class="function">IceConnectionInUse</code>
- the connection was not closed at this time, because it is being used by
other active protocols.</p></li><li class="listitem"><p><code class="function">IceStartedShutdownNegotiation</code>
- the connection was not closed at this time and shutdown negotiation started
with the client on the other side of the ICE connection.  When the connection
is actually closed,
<code class="function">IceProcessMessages</code>
will return a status of
<code class="function">IceProcessMessagesConnectionClosed</code></p></li></ul></div><p>When it is known that the client on the other side of the ICE connection
has terminated the connection without initiating shutdown negotiation, the
<code class="function">IceSetShutdownNegotiation</code>
function should be called to turn off shutdown negotiation.  This will prevent
<code class="function">IceCloseConnection</code>
from writing to a broken connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncIceSetShutdownNegotiation</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> negotiate</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>Bool<var class="pdparam"> negotiate</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>negotiate</em></span></span></dt><dd><p>If
<code class="function">False</code>
shutdown negotiating will be turned off.</p></dd></dl></div><p>To check the shutdown negotiation status of an ICE connection, use
<code class="function">IceCheckShutdownNegotiation</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Bool <strong>fsfuncIceCheckShutdownNegotiation</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd></dl></div><p><code class="function">IceCheckShutdownNegotiation</code>
returns
<code class="function">True</code>
if shutdown negotiation will take place on the connection;
otherwise, it returns
<code class="function">False</code>
Negotiation is on by default for a connection.  It
can only be changed with the
<code class="function">IceSetShutdownNegotiation</code>
function.</p></div><div class="sect1" title="Connection Watch Procedures"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="connection_watch_procedures"></a>Connection Watch Procedures</h2></div></div></div><p>To add a watch procedure that will be called
each time ICElib opens a new connection via
<code class="function">IceOpenConnection</code>
or
<code class="function">IceAcceptConnection</code>
or closes a connection via
<code class="function">IceCloseConnection</code>
use
<code class="function">IceAddConnectionWatch</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status <strong>fsfuncIceAddConnectionWatch</strong>(</code></td><td><var class="pdparam"> watch_proc</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceWatchProc<var class="pdparam"> watch_proc</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>watch_proc</em></span></span></dt><dd><p>
The watch procedure to invoke when ICElib opens or closes a connection.
      </p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>This pointer will be passed to the watch procedure.</p></dd></dl></div><p>
The return value of <code class="function">IceAddConnectionWatch</code>
is zero for failure, and a positive value for success.
</p><p>
Note that several calls to <code class="function">IceOpenConnection</code>
might share the same ICE connection.  In such a case, the watch procedure
is only invoked when the connection is first created (after authentication
succeeds).  Similarly, because connections might be shared, the
watch procedure is called only if <code class="function">IceCloseConnection</code>
actually closes the connection (right before the IceConn is freed).
</p><p>
The watch procedures are very useful for applications that
need to add a file descriptor to a select mask when a new connection
is created and remove the file descriptor when the connection is destroyed.
Because connections are shared, knowing when to add and remove the file
descriptor from the select mask would be difficult without the watch
procedures.
</p><p>
Multiple watch procedures may be registered with the ICE library.
No assumptions should be made about their order of invocation.
</p><p>
If one or more ICE connections were already created by the ICE library at the
time the watch procedure is registered, the watch procedure will instantly
be invoked for each of these ICE connections (with the opening argument
set to <code class="function">True</code>
</p><p>
The watch procedure is of type <code class="function">IceWatchProc</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncWatchProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> opening</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *watch_data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;<br /><code>Bool<var class="pdparam"> opening</var></code>;<br /><code>IcePointer<var class="pdparam"> *watch_data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>
The opened or closed ICE connection.  Call
<code class="function">IceConnectionNumber</code>
to get the file descriptor associated with this connection.
      </p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>
Client data specified in the call to
<code class="function">IceAddConnectionWatch</code>
      </p></dd><dt><span class="term"><span class="emphasis"><em>opening</em></span></span></dt><dd><p>
If <code class="function">True</code> the connection is being opened.  If
<code class="function">False</code> the connection is being closed.
      </p></dd><dt><span class="term"><span class="emphasis"><em>watch_data</em></span></span></dt><dd><p>Can be used to save a pointer to client data.</p></dd></dl></div><p>
If opening is <code class="function">True</code> the client should set the
*watch_data pointer to any data it may need to save until the connection
is closed and the watch procedure is invoked again with opening set to
<code class="function">False</code>
</p><p>
To remove a watch procedure, use
<code class="function">IceRemoveConnectionWatch</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncIceRemoveConnectionWatch</strong>(</code></td><td><var class="pdparam"> watch_proc</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceWatchProc<var class="pdparam"> watch_proc</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>watch_proc</em></span></span></dt><dd><p>
The watch procedure that was passed to
<code class="function">IceAddConnectionWatch</code>
      </p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>
The client_data pointer that was passed to
<code class="function">IceAddConnectionWatch</code>
      </p></dd></dl></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp3147504" href="#idp3147504" class="para">1</a>] </sup>The X Consortium's ICElib implementation uses an .ICEauthority file (see
Appendix A).
  </p></div></div></div><div class="chapter" title="Chapter 8. Protocol Setup and Shutdown"><div class="titlepage"><div><div><h2 class="title"><a id="protocol_setup_and_shutdown"></a>Chapter 8. Protocol Setup and Shutdown</h2></div></div></div><p>
To activate a protocol on a given ICE connection, use
<code class="function">IceProtocolSetup</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceProtocolSetupStatus <strong>fsfuncIceProtocolSetup</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> my_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> must_authenticate</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *major_version_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *minor_version_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **vendor_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> **release_ret</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> error_length</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *error_string_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> my_opcode</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;<br /><code>Bool<var class="pdparam"> must_authenticate</var></code>;<br /><code>int<var class="pdparam"> *major_version_ret</var></code>;<br /><code>int<var class="pdparam"> *minor_version_ret</var></code>;<br /><code>char<var class="pdparam"> **vendor_ret</var></code>;<br /><code>char<var class="pdparam"> **release_ret</var></code>;<br /><code>int<var class="pdparam"> error_length</var></code>;<br /><code>char<var class="pdparam"> *error_string_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>my_opcode</em></span></span></dt><dd><p>
The major opcode of the protocol to be set up, as returned by
<code class="function">IceRegisterForProtocolSetup</code>
      </p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>
The client data stored in this pointer will be passed to the
<code class="function">IcePoProcessMsgProc</code> callback.
      </p></dd><dt><span class="term"><span class="emphasis"><em>must_authenticate</em></span></span></dt><dd><p>
If <code class="function">True</code> the other client may
not bypass authentication.
      </p></dd><dt><span class="term"><span class="emphasis"><em>major_version_ret</em></span></span></dt><dd><p>The major version of the protocol to be used is returned.</p></dd><dt><span class="term"><span class="emphasis"><em>minor_version_ret</em></span></span></dt><dd><p>The minor version of the protocol to be used is returned.</p></dd><dt><span class="term"><span class="emphasis"><em>vendor_ret</em></span></span></dt><dd><p>The vendor string specified by the protocol acceptor.</p></dd><dt><span class="term"><span class="emphasis"><em>release_ret</em></span></span></dt><dd><p>The release string specified by the protocol acceptor.</p></dd><dt><span class="term"><span class="emphasis"><em>error_length</em></span></span></dt><dd><p>
Specifies the length of the error_string_ret argument passed in.
      </p></dd><dt><span class="term"><span class="emphasis"><em>error_string_ret</em></span></span></dt><dd><p>
Returns a null-terminated error message, if any.
The error_string_ret argument points to user supplied memory.
No more than error_length bytes are used.
      </p></dd></dl></div><p>
The vendor_ret and release_ret strings should be freed with
<code class="function">free</code> when no longer needed.
</p><p>
<code class="function">IceProtocolSetup</code> returns one of the following values:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="function">IceProtocolSetupSuccess</code> - the major_version_ret,
minor_version_ret, vendor_ret, release_ret are set.
    </p></li><li class="listitem"><p>
<code class="function">IceProtocolSetupFailure</code> or
<code class="function">IceProtocolSetupIOError</code>
- check error_string_ret for failure reason.  The major_version_ret,
minor_version_ret, vendor_ret, release_ret are not set.
    </p></li><li class="listitem"><p>
<code class="function">IceProtocolAlreadyActive</code>
- this protocol is already active on this connection.
The major_version_ret, minor_version_ret, vendor_ret, release_ret
are not set.
    </p></li></ul></div><p>
To notify the ICE library when a given protocol will no longer be used
on an ICE connection, use <code class="function">IceProtocolShutdown</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status <strong>fsfuncIceProtocolShutdown</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> major_opcode</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> major_opcode</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>major_opcode</em></span></span></dt><dd><p>The major opcode of the protocol to shut down.</p></dd></dl></div><p>
The return value of <code class="function">IceProtocolShutdown</code>
is zero for failure and a positive value for success.
</p><p>
Failure will occur if the major opcode was never registered OR the protocol
of the major opcode was never activated on the connection.  By activated,
we mean that a <code class="function">ProtocolSetup</code> succeeded on the connection.
Note that ICE does not define how each sub-protocol triggers a
protocol shutdown.
</p></div><div class="chapter" title="Chapter 9. Processing Messages"><div class="titlepage"><div><div><h2 class="title"><a id="processing_messages"></a>Chapter 9. Processing Messages</h2></div></div></div><p>To process incoming messages on an ICE connection, use
<code class="function">IceProcessMessages</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceProcessMessagesStatus <strong>fsfuncIceProcessMessages</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *reply_wait</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *reply_ready_ret</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IceReplyWaitInfo<var class="pdparam"> *reply_wait</var></code>;<br /><code>Bool<var class="pdparam"> *reply_ready_ret</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_wait</em></span></span></dt><dd><p>Indicates if a reply is being waited for.</p></dd><dt><span class="term"><span class="emphasis"><em>reply_ready_ret</em></span></span></dt><dd><p>
If set to <code class="function">True</code> on return, a reply is ready.
      </p></dd></dl></div><p>
<code class="function">IceProcessMessages</code> is used in two ways:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
In the first, a client may generate a message and block by calling
<code class="function">IceProcessMessages</code> repeatedly until it gets its reply.
    </p></li><li class="listitem"><p>
In the second, a client calls <code class="function">IceProcessMessages</code>
with reply_wait set to NULL in response to <code class="function">select</code>
showing that there is data to read on the ICE connection.
The ICE library may process zero or more complete messages.
Note that messages that are not blocked for are always processed by
invoking callbacks.
    </p></li></ul></div><p>
<code class="function">IceReplyWaitInfo</code> contains the major/minor opcodes
and sequence number of the message for which a reply is being awaited.
It also contains a pointer to the reply message to be filled in (the
protocol library should cast this <code class="function">IcePointer</code>
to the appropriate reply type).  In most
cases, the reply will have some fixed-size part, and the client waiting
for the reply will have provided a pointer to a structure to hold
this fixed-size data.  If there is variable-length data, it would be
expected that the
<code class="function">IcePoProcessMsgProc</code>
callback will have to allocate additional
memory and store pointer(s) to that memory in the fixed-size
structure.  If the entire data is variable length (for example, a single
variable-length string), then the client waiting for the reply would probably
just pass a pointer to fixed-size space to hold a pointer, and the
<code class="function">IcePoProcessMsgProc</code>
callback would allocate the storage and store the pointer.
It is the responsibility of the client receiving the reply to
free up any memory allocated on its behalf.
</p><pre class="literallayout">
typedef struct {
     unsigned long sequence_of_request;
     int major_opcode_of_request;
     int minor_opcode_of_request;
     IcePointer reply;
} IceReplyWaitInfo;
</pre><p>
If reply_wait is not NULL and
<code class="function">IceProcessMessages</code>
has a reply or error to return in response to this reply_wait
(that is, no callback was generated), then the reply_ready_ret argument
will be set to <code class="function">True</code>
</p><p>
If reply_wait is NULL, then the caller may also pass NULL for
reply_ready_ret and be guaranteed that no value will be stored in
this pointer.
</p><p>
<code class="function">IceProcessMessages</code> returns one of the following values:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="function">IceProcessMessagesSuccess</code> - no error occurred.
    </p></li><li class="listitem"><p>
<code class="function">IceProcessMessagesIOError</code> - an IO error occurred,
and the caller must explicitly close the connection by calling
<code class="function">IceCloseConnection</code>
    </p></li><li class="listitem"><p>
<code class="function">IceProcessMessagesConnectionClosed</code>
- the ICE connection has been closed (closing of the connection was deferred
because of shutdown negotiation, or because the
<code class="function">IceProcessMessages</code>
nesting level was not zero).  Do not attempt
to access the ICE connection at this point, since it has been freed.
    </p></li></ul></div></div><div class="chapter" title="Chapter 10. Ping"><div class="titlepage"><div><div><h2 class="title"><a id="ping"></a>Chapter 10. Ping</h2></div></div></div><p>
To send a "Ping" message to the client on the other side of the
ICE connection, use <code class="function">IcePing</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status <strong>fsfuncIcePing</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> ping_reply_proc</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePingReplyProc<var class="pdparam"> ping_reply_proc</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>ping_reply_proc</em></span></span></dt><dd><p>The callback to invoke when the Ping reply arrives.</p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>
This pointer will be passed to the <code class="function">IcePingReplyProc</code>
callback.
      </p></dd></dl></div><p><code class="function">IcePing</code>
returns zero for failure and a positive value for success.</p><p>When
<code class="function">IceProcessMessages</code>
processes the Ping reply, it will invoke the
<code class="function">IcePingReplyProc</code>
callback.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <strong>fsfuncPingReplyProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> client_data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>IcePointer<var class="pdparam"> client_data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>client_data</em></span></span></dt><dd><p>The client data specified in the call to
<code class="function">IcePing</code></p></dd></dl></div></div><div class="chapter" title="Chapter 11. Using ICElib Informational Functions"><div class="titlepage"><div><div><h2 class="title"><a id="using_icelib_informational_functions"></a>Chapter 11. Using ICElib Informational Functions</h2></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceConnectStatus <strong>fsfuncIceConnectionStatus</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceConnectionStatus</code>
returns the status of an ICE connection.  The possible return values are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="function">IceConnectPending</code>
- the connection is not valid yet (that is, authentication is taking place).
This is only relevant to connections created by
<code class="function">IceAcceptConnection</code></p></li><li class="listitem"><p><code class="function">IceConnectAccepted</code>
- the connection has been accepted.
This is only relevant to connections created by
<code class="function">IceAcceptConnection</code></p></li><li class="listitem"><p><code class="function">IceConnectRejected</code>
- the connection had been rejected  (that is, authentication failed).
This is only relevant to connections created by
<code class="function">IceAcceptConnection</code></p></li><li class="listitem"><p><code class="function">IceConnectIOError</code>
- an IO error has occurred on the connection.</p></li></ul></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char <strong>fsfunc *IceVendor</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceVendor</code>
returns the ICE library vendor identification
for the other side of the connection.
The string should be freed with a call to
<code class="function">free</code>
when no longer needed.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char <strong>fsfunc *IceRelease</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceRelease</code>
returns the release identification of the ICE library
on the other side of the connection.
The string should be freed with a call to
<code class="function">free</code>
when no longer needed.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfunc IceProtocolVersion</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceProtocolVersion</code>
returns the major version of the ICE protocol on this connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfunc IceProtocolRevision</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceProtocolRevision</code>
returns the minor version of the ICE protocol on this connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfunc IceConnectionNumber</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceConnectionNumber</code>
returns the file descriptor of this ICE connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char <strong>fsfunc *IceConnectionString</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceConnectionString</code>
returns the network ID of the client that
accepted this connection.  The string should be freed with a call to
<code class="function">free</code>
when no longer needed.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned long <strong>fsfunc IceLastSentSequenceNumber</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceLastSentSequenceNumber</code>
returns the sequence number of the last message sent on this ICE connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned long <strong>fsfunc IceLastReceivedSequenceNumber</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceLastReceivedSequenceNumber</code>
returns the sequence number of the last message received on this
ICE connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Bool <strong>fsfunc IceSwapping</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceSwapping</code>
returns
<code class="function">True</code>
if byte swapping is necessary when reading messages on the ICE connection.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IcePointer <strong>fsfunc IceGetContext</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><p><code class="function">IceGetContext</code>
returns the context associated with a connection created by
<code class="function">IceOpenConnection</code></p></div><div class="chapter" title="Chapter 12. ICE Messages"><div class="titlepage"><div><div><h2 class="title"><a id="ice_messages"></a>Chapter 12. ICE Messages</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#sending_ice_messages">Sending ICE Messages</a></span></dt><dt><span class="sect1"><a href="#reading_ice_messages">Reading ICE Messages</a></span></dt></dl></div><p>
All ICE messages have a standard 8-byte header.  The ICElib macros that
read and write messages rely on the following naming convention for message
headers:
</p><pre class="literallayout">
     CARD8	major_opcode;
     CARD8	minor_opcode;
     CARD8	data[2];
     CARD32	length B32;
</pre><p>
The 3rd and 4th bytes of the message header can be used as needed.
The length field is specified in units of 8 bytes.
</p><div class="sect1" title="Sending ICE Messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sending_ice_messages"></a>Sending ICE Messages</h2></div></div></div><p>
The ICE library maintains an output buffer used for generating messages.
Protocol libraries layered on top of ICE may choose to batch messages
together and flush the output buffer at appropriate times.
</p><p>
If an IO error has occurred on an ICE connection, all write operations
will be ignored.  For further information, see
<a class="link" href="#error_handling" title="Chapter 13. Error Handling">
<a class="xref" href="#error_handling" title="Chapter 13. Error Handling">Chapter 13, <em>Error Handling</em></a></a>.
</p><p>
To get the size of the ICE output buffer, use
<code class="function">IceGetOutBufSize</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfunc IceGetOutBufSize</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd></dl></div><p>
To flush the ICE output buffer, use <code class="function">IceFlush</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <strong>fsfunc IceFlush</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd></dl></div><p>
Note that the output buffer may be implicitly flushed if there is
insufficient space to generate a message.
</p><p>The following macros can be used to generate ICE messages:</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceGetHeader</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> major_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> minor_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> header_size</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pmsg</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> major_opcode</var></code>;<br /><code>int<var class="pdparam"> minor_opcode</var></code>;<br /><code>int<var class="pdparam"> header_size</var></code>;<br /><code>&lt;C_data_type&gt;<var class="pdparam"> *pmsg</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>major_opcode</em></span></span></dt><dd><p>The major opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>minor_opcode</em></span></span></dt><dd><p>The minor opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>header_size</em></span></span></dt><dd><p>The size of the message header (in bytes).</p></dd><dt><span class="term"><span class="emphasis"><em>&lt;C_data_type&gt;</em></span></span></dt><dd><p>The actual C data type of the message header.</p></dd><dt><span class="term"><span class="emphasis"><em>pmsg</em></span></span></dt><dd><p>
The message header pointer.  After this macro is called, the
library can store data in the message header.
      </p></dd></dl></div><p>
<code class="function">IceGetHeader</code>
is used to set up a message header on an ICE connection.
It sets the major and minor opcodes of the message, and initializes
the message's length to the length of the header.  If additional
variable length data follows, the message's length field should be
updated.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceGetHeaderExtra</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> major_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> minor_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> header_size</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> extra</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pmsg</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pdata</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> major_opcode</var></code>;<br /><code>int<var class="pdparam"> minor_opcode</var></code>;<br /><code>int<var class="pdparam"> header_size</var></code>;<br /><code>int<var class="pdparam"> extra</var></code>;<br /><code>&lt;C_data_type&gt;<var class="pdparam"> *pmsg</var></code>;<br /><code>char<var class="pdparam"> *pdata</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>major_opcode</em></span></span></dt><dd><p>The major opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>minor_opcode</em></span></span></dt><dd><p>The minor opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>header_size</em></span></span></dt><dd><p>The size of the message header (in bytes).</p></dd><dt><span class="term"><span class="emphasis"><em>extra</em></span></span></dt><dd><p>
The size of the extra data beyond the header (in 8-byte units).
      </p></dd><dt><span class="term"><span class="emphasis"><em>&lt;C_data_type&gt;</em></span></span></dt><dd><p>The actual C data type of the message header.</p></dd><dt><span class="term"><span class="emphasis"><em>pmsg</em></span></span></dt><dd><p>
The message header pointer.  After this macro is called, the
library can store data in the message header.
      </p></dd><dt><span class="term"><span class="emphasis"><em>pdata</em></span></span></dt><dd><p>
Returns a pointer to the ICE output buffer that points
immediately after the message header.  The variable length
data should be stored here.  If there was not enough room
in the ICE output buffer, pdata is set to NULL.
      </p></dd></dl></div><p>
<code class="function">IceGetHeaderExtra</code>
is used to generate a message with a fixed (and relatively small) amount
of variable length data.  The complete message must fit in the ICE output
buffer.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceSimpleMessage</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> major_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> minor_opcode</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> major_opcode</var></code>;<br /><code>int<var class="pdparam"> minor_opcode</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>major_opcode</em></span></span></dt><dd><p>The major opcode of the message.</p></dd><dt><span class="term"><span class="emphasis"><em>minor_opcode</em></span></span></dt><dd><p>The minor opcode of the message.</p></dd></dl></div><p>
<code class="function">IceSimpleMessage</code>
is used to generate a message that is identical
in size to the ICE header message, and has no additional data.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceErrorHeader</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> offending_major_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> offending_minor_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> offending_sequence_num</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> severity</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> error_class</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> data_length</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> offending_major_opcode</var></code>;<br /><code>int<var class="pdparam"> offending_minor_opcode</var></code>;<br /><code>int<var class="pdparam"> offending_sequence_num</var></code>;<br /><code>int<var class="pdparam"> severity</var></code>;<br /><code>int<var class="pdparam"> error_class</var></code>;<br /><code>int<var class="pdparam"> data_length</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>offending_major_opcode</em></span></span></dt><dd><p>
The major opcode of the protocol in which an error was detected.
      </p></dd><dt><span class="term"><span class="emphasis"><em>offending_minor_opcode</em></span></span></dt><dd><p>
The minor opcode of the protocol in which an error was detected.
      </p></dd><dt><span class="term"><span class="emphasis"><em>offending_sequence_num</em></span></span></dt><dd><p>The sequence number of the message that caused the error.</p></dd><dt><span class="term"><span class="emphasis"><em>severity</em></span></span></dt><dd><p>
<code class="function">IceCanContinue</code>
<code class="function">IceFatalToProtocol</code>
or
<code class="function">IceFatalToConnection</code>
      </p></dd><dt><span class="term"><span class="emphasis"><em>error_class</em></span></span></dt><dd><p>The error class.</p></dd><dt><span class="term"><span class="emphasis"><em>data_length</em></span></span></dt><dd><p>
Length of data (in 8-byte units) to be written after the header.
      </p></dd></dl></div><p>
<code class="function">IceErrorHeader</code> sets up an error message header.
</p><p>
Note that the two clients connected by ICE may be using different
major opcodes for a given protocol.  The offending_major_opcode passed
to this macro is the major opcode of the protocol for the client
sending the error message.
</p><p>
Generic errors, which are common to all protocols, have classes
in the range 0x8000..0xFFFF.
See the <span class="emphasis"><em>Inter-Client Exchange Protocol</em></span>
standard for more details.
</p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /></colgroup><tbody><tr><td align="left">IceBadMinor</td><td align="left">0x8000</td></tr><tr><td align="left">IceBadState</td><td align="left">0x8001</td></tr><tr><td align="left">IceBadLength</td><td align="left">0x8002</td></tr><tr><td align="left">IceBadValue</td><td align="left">0x8003</td></tr></tbody></table></div><p>Per-protocol errors have classes in the range 0x0000-0x7fff.</p><p>
To write data to an ICE connection, use the
<code class="function">IceWriteData</code> macro.  If the data fits into the
ICE output buffer, it is copied there.  Otherwise, the ICE output buffer
is flushed and the data is directly sent.
</p><p>
This macro is used in conjunction with
<code class="function">IceGetHeader</code> and
<code class="function">IceErrorHeader</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceWriteData</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to write.</p></dd><dt><span class="term"><span class="emphasis"><em>data</em></span></span></dt><dd><p>The data to write.</p></dd></dl></div><p>
To write data as 16-bit quantities, use <code class="function">IceWriteData16</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceWriteData16</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to write.</p></dd><dt><span class="term"><span class="emphasis"><em>data</em></span></span></dt><dd><p>The data to write.</p></dd></dl></div><p>
To write data as 32-bit quantities, use <code class="function">IceWriteData32</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceWriteData32</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to write.</p></dd><dt><span class="term"><span class="emphasis"><em>data</em></span></span></dt><dd><p>The data to write.</p></dd></dl></div><p>
To write data as 32-bit quantities, use <code class="function">IceWriteData32</code>
</p><p>
To bypass copying data to the ICE output buffer, use
<code class="function">IceSendData</code> to directly send data over the network
connection.  If necessary, the ICE output buffer is first flushed.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceSendData</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to send.</p></dd><dt><span class="term"><span class="emphasis"><em>data</em></span></span></dt><dd><p>The data to send.</p></dd></dl></div><p>
To force 32-bit or 64-bit alignment, use <code class="function">IceWritePad</code>
A maximum of 7 pad bytes can be specified.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceWritePad</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *data</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to write.</p></dd><dt><span class="term"><span class="emphasis"><em>data</em></span></span></dt><dd><p>The number of pad bytes to write.</p></dd></dl></div></div><div class="sect1" title="Reading ICE Messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="reading_ice_messages"></a>Reading ICE Messages</h2></div></div></div><p>
The ICE library maintains an input buffer used for reading messages.
If the ICE library chooses to perform nonblocking reads (this is
implementation-dependent), then for every read operation that it makes,
zero or more complete messages may be read into the input buffer.  As
a result, for all of the macros described in this section that read
messages, an actual read operation will occur on the connection only if
the data is not already present in the input buffer.
</p><p>
To get the size of the ICE input buffer, use
<code class="function">IceGetInBufSize</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int<strong>fsfunc IceGetInBufSize</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd></dl></div><p>
When reading messages, care must be taken to check for IO errors.  If
any IO error occurs in reading any part of a message, the message should
be thrown out.  After using any of the macros described below for reading
messages, the <code class="function">IceValidIO</code>
macro can be used to check if an IO error occurred on the
connection.  After an IO error has occurred on an ICE connection, all
read operations will be ignored.  For further information, see
<a class="link" href="#error_handling" title="Chapter 13. Error Handling">
<a class="xref" href="#error_handling" title="Chapter 13. Error Handling">Chapter 13, <em>Error Handling</em></a></a>.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Bool<strong>fsfunc IceValidIO</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd></dl></div><p>The following macros can be used to read ICE messages.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadSimpleMessage</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pmsg</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>&lt;C_data_type&gt;<var class="pdparam"> *pmsg</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>&lt;C_data_type&gt;</em></span></span></dt><dd><p>The actual C data type of the message header.</p></dd><dt><span class="term"><span class="emphasis"><em>pmsg</em></span></span></dt><dd><p>This pointer is set to the message header.</p></dd></dl></div><p>
<code class="function">IceReadSimpleMessage</code>
is used for messages that are identical in size to the 8-byte ICE header, but
use the spare 2 bytes in the header to encode additional data.  Note that the
ICE library always reads in these first 8 bytes, so it can obtain the major
opcode of the message.  <code class="function">IceReadSimpleMessage</code>
simply returns a pointer to these 8 bytes; it does not actually read any data
into the input buffer.
</p><p>
For a message with variable length data, there are two ways of reading
the message.  One method involves reading the complete message in one
pass using <code class="function">IceReadCompleteMessage</code>
The second method involves reading the message header (note that this may
be larger than the 8-byte ICE header), then reading
the variable length data in chunks (see
<code class="function">IceReadMessageHeader</code> and
<code class="function">IceReadData</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadCompleteMessage</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> header_size</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pmsg</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pdata</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> header_size</var></code>;<br /><code>&lt;C_data_type&gt;<var class="pdparam"> *pmsg</var></code>;<br /><code>char<var class="pdparam"> *pdata</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>header_size</em></span></span></dt><dd><p>The size of the message header (in bytes).</p></dd><dt><span class="term"><span class="emphasis"><em>&lt;C_data_type&gt;</em></span></span></dt><dd><p>The actual C data type of the message header.</p></dd><dt><span class="term"><span class="emphasis"><em>pmsg</em></span></span></dt><dd><p>This pointer is set to the message header.</p></dd><dt><span class="term"><span class="emphasis"><em>pdata</em></span></span></dt><dd><p>
This pointer is set to the variable length data of the message.
      </p></dd></dl></div><p>
If the ICE input buffer has sufficient space,
<code class="function">IceReadCompleteMessage</code>
will read the complete message into the
ICE input buffer.  Otherwise, a buffer will be allocated to hold the
variable length data.  After the call, the pdata argument should
be checked against NULL to make sure that there was sufficient memory
to allocate the buffer.
</p><p>
After calling <code class="function">IceReadCompleteMessage</code>
and processing the message, <code class="function">IceDisposeCompleteMessage</code>
should be called.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceDisposeCompleteMessage</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pdata</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>char<var class="pdparam"> *pdata</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>pdata</em></span></span></dt><dd><p>
The pointer to the variable length data returned in
<code class="function">IceReadCompleteMessage</code>
      </p></dd></dl></div><p>
If a buffer had to be allocated to hold the variable length data (because
it did not fit in the ICE input buffer), it is freed here by ICElib.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadMessageHeader</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> header_size</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pmsg</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> header_size</var></code>;<br /><code>&lt;C_data_type&gt;<var class="pdparam"> *pmsg</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>header_size</em></span></span></dt><dd><p>The size of the message header (in bytes).</p></dd><dt><span class="term"><span class="emphasis"><em>&lt;C_data_type&gt;</em></span></span></dt><dd><p>The actual C data type of the message header.</p></dd><dt><span class="term"><span class="emphasis"><em>pmsg</em></span></span></dt><dd><p>This pointer is set to the message header.</p></dd></dl></div><p>
<code class="function">IceReadMessageHeader</code> reads just the message header.
The rest of the data should be read with the
<code class="function">IceReadData</code>
family of macros.  This method of reading a message should be used when the
variable length data must be read in chunks.
</p><p>
To read data directly into a user supplied buffer, use
<code class="function">IceReadData</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadData</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pdata</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *pdata</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to read.</p></dd><dt><span class="term"><span class="emphasis"><em>pdata</em></span></span></dt><dd><p>The data is read into this user supplied buffer.</p></dd></dl></div><p>
To read data as 16-bit quantities, use <code class="function">IceReadData16</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadData16</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> swap</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pdata</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>Bool<var class="pdparam"> swap</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *pdata</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>
If <code class="function">True,</code> the values will be byte swapped.
      </p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to read.</p></dd><dt><span class="term"><span class="emphasis"><em>pdata</em></span></span></dt><dd><p>The data is read into this user supplied buffer.</p></dd></dl></div><p>
To read data as 32-bit quantities, use <code class="function">IceReadData32</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadData32</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> swap</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *pdata</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>Bool<var class="pdparam"> swap</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;<br /><code>char<var class="pdparam"> *pdata</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>
If <code class="function">True,</code> the values will be byte swapped.
      </p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of bytes to read.</p></dd><dt><span class="term"><span class="emphasis"><em>pdata</em></span></span></dt><dd><p>The data is read into this user supplied buffer.</p></dd></dl></div><p>To force 32-bit or 64-bit alignment, use
<code class="function">IceReadPad</code>
A maximum of 7 pad bytes can be specified.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceReadPad</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>A valid ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>bytes</em></span></span></dt><dd><p>The number of pad bytes.</p></dd></dl></div></div></div><div class="chapter" title="Chapter 13. Error Handling"><div class="titlepage"><div><div><h2 class="title"><a id="error_handling"></a>Chapter 13. Error Handling</h2></div></div></div><p>There are two default error handlers in ICElib:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
One to handle typically fatal conditions (for example,
a connection dying because a machine crashed)
    </p></li><li class="listitem"><p>One to handle ICE-specific protocol errors</p></li></ul></div><p>
These error handlers can be changed to user-supplied routines if you
prefer your own error handling and can be changed as often as you like.
</p><p>
To set the ICE error handler, use <code class="function">IceSetErrorHandler</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef"><strong>fsfunc IceSetErrorHandler</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> bytes</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>int<var class="pdparam"> bytes</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>handler</em></span></span></dt><dd><p>
The ICE error handler.  You should pass NULL to restore the default handler.
      </p></dd></dl></div><p>
<code class="function">IceSetErrorHandler</code> returns the previous error handler.
</p><p>
The ICE error handler is invoked when an unexpected ICE protocol
error (major opcode 0) is encountered.  The action of the default
handler is to print an explanatory message to
<code class="function">stderr</code>
and if the severity is fatal, call
<code class="function">exit</code>
with a nonzero value.  If exiting
is undesirable, the application should register its own error handler.
</p><p>
Note that errors in other protocol
domains should be handled by their respective libraries (these libraries
should have their own error handlers).
</p><p>
An ICE error handler has the type of <code class="function">IceErrorHandler</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceErrorHandler</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> swap</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> offending_minor_opcode</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> offending_sequence_num</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> error_class</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> severity</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> values</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>Bool<var class="pdparam"> swap</var></code>;<br /><code>int<var class="pdparam"> offending_minor_opcode</var></code>;<br /><code>unsigned long<var class="pdparam"> offending_sequence_num</var></code>;<br /><code>int<var class="pdparam"> error_class</var></code>;<br /><code>int<var class="pdparam"> severity</var></code>;<br /><code>IcePointer<var class="pdparam"> values</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>handler</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>swap</em></span></span></dt><dd><p>A flag that indicates if the values need byte swapping.</p></dd><dt><span class="term"><span class="emphasis"><em>offending_minor_opcode</em></span></span></dt><dd><p>The ICE minor opcode of the offending message.</p></dd><dt><span class="term"><span class="emphasis"><em>offending_sequence_num</em></span></span></dt><dd><p>The sequence number of the offending message.</p></dd><dt><span class="term"><span class="emphasis"><em>error_class</em></span></span></dt><dd><p>The error class of the offending message.</p></dd><dt><span class="term"><span class="emphasis"><em>severity</em></span></span></dt><dd><p>
<code class="function">IceCanContinue</code>
<code class="function">IceFatalToProtocol</code>
or
<code class="function">IceFatalToConnection</code>
      </p></dd><dt><span class="term"><span class="emphasis"><em>values</em></span></span></dt><dd><p>
Any additional error values specific to the minor opcode and class.
      </p></dd></dl></div><p>The following error classes are defined at the ICE level:</p><div class="literallayout"><p><br />
<code class="function">IceBadMinor</code><br />
<code class="function">IceBadState</code><br />
<code class="function">IceBadLength</code><br />
<code class="function">IceBadValue</code><br />
<code class="function">IceBadMajor</code><br />
<code class="function">IceNoAuth</code><br />
<code class="function">IceNoVersion</code><br />
<code class="function">IceSetupFailed</code><br />
<code class="function">IceAuthRejected</code><br />
<code class="function">IceAuthFailed</code><br />
<code class="function">IceProtocolDuplicate</code><br />
<code class="function">IceMajorOpcodeDuplicate</code><br />
<code class="function">IceUnknownProtocol</code><br />
</p></div><p>
For further information, see
the <span class="emphasis"><em>Inter-Client Exchange Protocol</em></span> standard.
</p><p>
To handle fatal I/O errors, use <code class="function">IceSetIOErrorHandler</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceIOErrorHandler<strong>fsfunc IceSetIOErrorHandler</strong>(</code></td><td><var class="pdparam"> handler</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceIOErrorHandler<var class="pdparam"> handler</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>handler</em></span></span></dt><dd><p>
The I/O error handler.  You should pass NULL to restore the default handler.
      </p></dd></dl></div><p>
<code class="function">IceSetIOErrorHandler</code> returns the previous
IO error handler.
</p><p>
An ICE I/O error handler has the type of
<code class="function">IceIOErrorHandler</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceIOErrorHandler</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd></dl></div><p> There are two ways of handling IO errors in ICElib:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
In the first, the IO error handler does whatever is necessary
to respond to the IO error and then returns, but it does not call
<code class="function">IceCloseConnection</code>
The ICE connection is given a "bad IO" status, and all future reads
and writes to the connection are ignored.  The next time
<code class="function">IceProcessMessages</code>
is called it will return a status of
<code class="function">IceProcessMessagesIOError</code>
At that time, the application should call
<code class="function">IceCloseConnection</code>
    </p></li><li class="listitem"><p>
In the second, the IO error handler does call
<code class="function">IceCloseConnection</code>
and then uses the <code class="function">longjmp</code>
call to get back to the application's main event loop.  The
<code class="function">setjmp</code> and
<code class="function">longjmp</code>
calls may not work properly on all platforms,
and special care must be taken to avoid memory leaks.
Therefore, this second model is less desirable.
    </p></li></ul></div><p>
Before the application I/O error handler is invoked, protocol libraries
that were interested in being notified of I/O errors will have their
<code class="function">IceIOErrorProc</code>
handlers invoked.  This handler is set up in the protocol registration
functions (see <code class="function">IceRegisterForProtocolSetup</code> and
<code class="function">IceRegisterForProtocolReply</code>
and could be used to clean up state specific to the protocol.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceIOErrorProc</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd></dl></div><p>
Note that every <code class="function">IceIOErrorProc</code>
callback must return.  This is required
because each active protocol must be notified of the broken connection,
and the application IO error handler must be invoked afterwards.
</p></div><div class="chapter" title="Chapter 14. Multi-Threading Support"><div class="titlepage"><div><div><h2 class="title"><a id="multithreading_support"></a>Chapter 14. Multi-Threading Support</h2></div></div></div><p>To declare that multiple threads in an application will be using the ICE
library, use
<code class="function">IceInitThreads</code></p><div class="literallayout"><p><br />
Status IceInitThreads()<br />
</p></div><p>The
<code class="function">IceInitThreads</code>
function must be the first ICElib function a
multi-threaded program calls.  It must complete before any other ICElib
call is made.
<code class="function">IceInitThreads</code>
returns a nonzero status if and only if it was able
to initialize the threads package successfully.
It is safe to call
<code class="function">IceInitThreads</code>
more than once, although the threads package will only be initialized once.</p><p>Protocol libraries layered on top of ICElib will have to lock critical
sections of code that access an ICE connection (for example, when
generating messages).  Two calls, which are generally implemented as
macros, are provided:</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceLockConn</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceUnlockConn</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd></dl></div><p>To keep an ICE connection locked across several ICElib calls, applications use
<code class="function">IceAppLockConn</code>
and
<code class="function">IceAppUnlockConn</code></p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceAppLockConn</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd></dl></div><p>The
<code class="function">IceAppLockConn</code>
function completely locks out other threads using the connection
until
<code class="function">IceAppUnlockConn</code>
is called.  Other threads attempting to use ICElib
calls on the connection will block.
If the program has not previously called
<code class="function">IceInitThreads</code>
<code class="function">IceAppLockConn</code>
has no effect.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceAppUnlockConn</strong>(</code></td><td><var class="pdparam"> ice_conn</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd></dl></div><p>The
<code class="function">IceAppUnlockConn</code>
function allows other threads to complete ICElib
calls on the connection that were blocked by a previous call to
<code class="function">IceAppLockConn</code>
from this thread.  If the program has not previously called
<code class="function">IceInitThreads</code>
<code class="function">IceAppUnlockConn</code>
has no effect.</p></div><div class="chapter" title="Chapter 15. Miscellaneous Functions"><div class="titlepage"><div><div><h2 class="title"><a id="miscellaneous_functions"></a>Chapter 15. Miscellaneous Functions</h2></div></div></div><p>To allocate scratch space (for example, when generating
messages with variable data), use
<code class="function">IceAllocScratch</code>
Each ICE connection has one scratch space associated with it.
The scratch space starts off as empty and grows as needed.
The contents of the scratch space is not guaranteed to be preserved
after any ICElib function is called.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char<strong>fsfunc *IceAllocScratch</strong>(</code></td><td><var class="pdparam"> ice_conn</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> size</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceConn<var class="pdparam"> ice_conn</var></code>;<br /><code>unsigned long<var class="pdparam"> size</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>ice_conn</em></span></span></dt><dd><p>The ICE connection object.</p></dd><dt><span class="term"><span class="emphasis"><em>size</em></span></span></dt><dd><p>The number of bytes required.</p></dd></dl></div><p>Note that the memory returned by
<code class="function">IceAllocScratch</code>
should not be freed by the caller.
The ICE library will free the memory when the ICE connection is closed.</p></div><div class="chapter" title="Chapter 16. Acknowledgements"><div class="titlepage"><div><div><h2 class="title"><a id="acknowledgements"></a>Chapter 16. Acknowledgements</h2></div></div></div><p>
Thanks to Bob Scheifler for his thoughtful input on the design
of the ICE library.  Thanks also to Jordan Brown, Larry Cable, Donna Converse,
Clive Feather, Stephen Gildea, Vania Joloboff, Kaleb Keithley,
Stuart Marks, Hiro Miyamoto, Ralph Swick, Jim VanGilder, and Mike Wexler.
</p></div><div class="appendix" title="Appendix A. Authentication Utility Functions"><div class="titlepage"><div><div><h2 class="title"><a id="authentication_utility_functions"></a>Appendix A. Authentication Utility Functions</h2></div></div></div><p>
As discussed in this document, the means by which authentication data
is obtained by the ICE library (for
<code class="function">ConnectionSetup</code>
messages or
<code class="function">ProtocolSetup</code>
messages) is implementation-dependent.†
<sup>[<a id="idp3574752" href="#ftn.idp3574752" class="footnote">2</a>]</sup>
</p><p>
This appendix describes some utility functions that manipulate an
ICE authority file.  The authority file can be used to pass authentication
data between clients.
</p><p>The basic operations on the .ICEauthority file are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Get file name</p></li><li class="listitem"><p>Lock</p></li><li class="listitem"><p>Unlock</p></li><li class="listitem"><p>Read entry</p></li><li class="listitem"><p>Write entry</p></li><li class="listitem"><p>Search for entry</p></li></ul></div><p>
These are fairly low-level operations, and it is expected that a program,
like "iceauth", would exist to add, remove, and display entries in the file.
</p><p>
In order to use these utility functions, the
&lt;<span class="symbol">X11/ICE/ICEutil.h</span>&gt;
header file must be included.
</p><p>
An entry in the .ICEauthority file is defined by the following data structure:
</p><pre class="literallayout">
typedef struct {
     char *protocol_name;
     unsigned short protocol_data_length;
     char *protocol_data;
     char *network_id;
     char *auth_name;
     unsigned short auth_data_length;
     char *auth_data;
} IceAuthFileEntry;
</pre><p>
The protocol_name member is either "ICE" for connection setup authentication
or the subprotocol name, such as "XSMP".  For each entry, protocol specific
data can be specified in the protocol_data member.  This can be used
to search for old entries that need to be removed from the file.
</p><p>
The network_id member is the network ID of the client accepting
authentication (for example, the network ID of a session manager).
A network ID has the following form:
</p><div class="informaltable"><table border="0"><colgroup><col align="center" class="c1" /><col align="center" class="c2" /><col align="center" class="c3" /></colgroup><tbody><tr><td align="left"> </td><td align="left">tcp/&lt;hostname&gt;:&lt;portnumber&gt;</td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left">decnet/&lt;hostname&gt;::&lt;objname&gt;</td><td align="left">or</td></tr><tr><td align="left"> </td><td align="left">local/&lt;hostname&gt;:&lt;path&gt;</td><td align="left"> </td></tr></tbody></table></div><p>
The auth_name member is the name of the authentication method.
The auth_data member is the actual authentication data,
and the auth_data_length member is the number of bytes in the data.
</p><p>
To obtain the default authorization file name, use
<code class="function">IceAuthFileName</code>
</p><div class="literallayout"><p><br />
char *IceAuthFileName()<br />
</p></div><p>
If the ICEAUTHORITY environment variable if set, this value is returned.
Otherwise, the default authorization file name is $HOME/.ICEauthority.
This name is statically allocated and should not be freed.
</p><p>
To synchronously update the authorization file, the file must
be locked with a call to
<code class="function">IceLockAuthFile</code>
This function takes advantage of the fact that the
<code class="function">link</code>
system call will fail if the name of the new link already exists.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int<strong>fsfunc IceLockAuthFile</strong>(</code></td><td><var class="pdparam"> *file_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> retries</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> timeout</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> dead</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *file_name</var></code>;<br /><code>int<var class="pdparam"> retries</var></code>;<br /><code>int<var class="pdparam"> timeout</var></code>;<br /><code>long<var class="pdparam"> dead</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>file_name</em></span></span></dt><dd><p>The authorization file to lock.</p></dd><dt><span class="term"><span class="emphasis"><em>retries</em></span></span></dt><dd><p>The number of retries.</p></dd><dt><span class="term"><span class="emphasis"><em>timeout</em></span></span></dt><dd><p>The number of seconds before each retry.</p></dd><dt><span class="term"><span class="emphasis"><em>dead</em></span></span></dt><dd><p>
If a lock already exists that is the specified dead seconds old,
it is broken.
A value of zero is used to unconditionally break an old lock.
      </p></dd></dl></div><p>One of three values is returned:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="function">IceAuthLockSuccess</code> - the lock succeeded.
    </p></li><li class="listitem"><p>
<code class="function">IceAuthLockError</code> - a system error occurred, and
<code class="function">errno</code> may prove useful.
    </p></li><li class="listitem"><p>
<code class="function">IceAuthLockTimeout</code> - the specified number of
retries failed.
    </p></li></ul></div><p>
To unlock an authorization file, use <code class="function">IceUnlockAuthFile</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int<strong>fsfunc IceUnlockAuthFile</strong>(</code></td><td><var class="pdparam"> *file_name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *file_name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>file_name</em></span></span></dt><dd><p>The authorization file to unlock.</p></dd></dl></div><p>
To read the next entry in an authorization file, use
<code class="function">IceReadAuthFileEntry</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceAuthFileEntry<strong>fsfunc *IceReadAuthFileEntry</strong>(</code></td><td><var class="pdparam"> *auth_file</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>FILE<var class="pdparam"> *auth_file</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>auth_file</em></span></span></dt><dd><p>The authorization file.</p></dd></dl></div><p>
Note that it is the responsibility of the application to open the file
for reading before calling this function.  If an error is encountered,
or there are no more entries to read, NULL is returned.
</p><p>
Entries should be free with a call to
<code class="function">IceFreeAuthFileEntry</code>
</p><p>
To write an entry in an authorization file, use
<code class="function">IceWriteAuthFileEntry</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">Status<strong>fsfunc IceWriteAuthFileEntry</strong>(</code></td><td><var class="pdparam"> *auth_file</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *entry</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>FILE<var class="pdparam"> *auth_file</var></code>;<br /><code>IceAuthFileEntry<var class="pdparam"> *entry</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>auth_file</em></span></span></dt><dd><p>The authorization file.</p></dd><dt><span class="term"><span class="emphasis"><em>entry</em></span></span></dt><dd><p>The entry to write.</p></dd></dl></div><p>
Note that it is the responsibility of the application to open the file
for writing before calling this function.  The function returns a nonzero
status if the operation was successful.
</p><p>
To search the default authorization file for an entry that matches a given
protocol_name/network_id/auth_name tuple, use
<code class="function">IceGetAuthFileEntry</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">IceAuthFileEntry<strong>fsfunc *IceGetAuthFileEntry</strong>(</code></td><td><var class="pdparam"> *protocol_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *network_id</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *auth_name</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>char<var class="pdparam"> *protocol_name</var></code>;<br /><code>char<var class="pdparam"> *network_id</var></code>;<br /><code>char<var class="pdparam"> *auth_name</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>auth_file</em></span></span></dt><dd><p>The name of the protocol to search on.</p></dd><dt><span class="term"><span class="emphasis"><em>network_id</em></span></span></dt><dd><p>The network ID to search on.</p></dd><dt><span class="term"><span class="emphasis"><em>auth_name</em></span></span></dt><dd><p>The authentication method to search on.</p></dd></dl></div><p>
If <code class="function">IceGetAuthFileEntry</code>
fails to find such an entry, NULL is returned.
</p><p>
To free an entry returned by
<code class="function">IceReadAuthFileEntry</code> or
<code class="function">IceGetAuthFileEntry</code> use
<code class="function">IceFreeAuthFileEntry</code>
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceFreeAuthFileEntry</strong>(</code></td><td><var class="pdparam"> *entry</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>IceAuthFileEntry<var class="pdparam"> *entry</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>entry</em></span></span></dt><dd><p>The entry to free.</p></dd></dl></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp3574752" href="#idp3574752" class="para">2</a>] </sup>The X Consortium's ICElib implementation assumes the presence of an
ICE authority file.
</p></div></div></div><div class="appendix" title="Appendix B. MIT-MAGIC-COOKIE-1 Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="mit_magic_cookie_1_authentication"></a>Appendix B. MIT-MAGIC-COOKIE-1 Authentication</h2></div></div></div><p>The X Consortium's ICElib implementation supports a simple
MIT-MAGIC-COOKIE-1 authentication scheme using the authority file utilities
described in Appendix A.</p><p>In this model, an application, such as a session manager, obtains a
magic cookie by calling
<code class="function">IceGenerateMagicCookie</code>
and then stores it in the user's local .ICEauthority file
so that local clients can connect.  In order to allow remote clients to
connect, some remote execution mechanism should be used to store the
magic cookie in the user's .ICEauthority file on a remote machine.</p><p>In addition to storing the magic cookie in the .ICEauthority file, the
application needs to call the
<code class="function">IceSetPaAuthData</code>
function in order to store the magic cookie in memory.  When it comes time
for the MIT-MAGIC-COOKIE-1 authentication procedure to accept or reject the
connection, it will compare the magic cookie presented by the requestor to
the magic cookie in memory.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">char<strong>fsfunc *IceGenerateMagicCookie</strong>(</code></td><td><var class="pdparam"> length</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>int<var class="pdparam"> length</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>length</em></span></span></dt><dd><p>The desired length of the magic cookie.</p></dd></dl></div><p>The magic cookie returned will be null-terminated.  If memory can not be
allocated for the magic cookie, the function will return NULL.
Otherwise, the magic cookie should be freed with a call to
<code class="function">free</code></p><p>To store the authentication data in memory, use
<code class="function">IceSetPaAuthData</code>
Currently, this function is only used for MIT-MAGIC-COOKIE-1
authentication, but it may be used for additional authentication
methods in the future.</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void<strong>fsfunc IceSetPaAuthData</strong>(</code></td><td><var class="pdparam"> num_entries</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam"> *entries</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>int<var class="pdparam"> num_entries</var></code>;<br /><code>IceAuthDataEntry<var class="pdparam"> *entries</var></code>;</div><div class="funcprototype-spacer"> </div></div><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>num_entries</em></span></span></dt><dd><p>The number of authentication data entries.</p></dd><dt><span class="term"><span class="emphasis"><em>entries</em></span></span></dt><dd><p>The list of authentication data entries.</p></dd></dl></div><p>Each entry has associated with it a protocol name
(for example, "ICE" for ICE connection setup authentication,
"XSMP" for session management authentication), a network ID for the
"accepting" client, an authentication name (for example, MIT-MAGIC-COOKIE-1),
and authentication data.  The ICE library
will merge these entries with previously set entries, based on the
(protocol_name, network_id, auth_name) tuple.</p><pre class="literallayout">
typedef struct {
	char *protocol_name;
	char *network_id;
	char *auth_name;
	unsigned short auth_data_length;
	char *auth_data;
} IceAuthDataEntry;
</pre></div></div></body></html>
